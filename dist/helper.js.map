{"mappings":"A,C,K,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,IcQI,EACA,EAkFA,E,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,M,EbxFQ,E,E,E,O,C,oB,I,G,E,E,O,C,uB,I,G,E,E,O,C,sB,I,GAHL,IAAM,EAAoB,4BACpB,EAAuB,8B,EAExB,EAAA,GAAA,CAAA,EAAA,CAAA,CAAA,E,C,E,K,C,E,C,Q,C,C,E,O,C,E,C,S,G,E,Q,S,C,C,C,E,E,E,O,C,kB,I,G,E,E,O,C,a,I,G,E,E,O,C,e,I,G,E,E,O,C,iB,I,G,I,E,E,S,E,E,SCQL,IAAM,EAAkB,CAAC,EAA6B,KAC3D,QAAQ,GAAG,CAAC,UAAW,eACvB,OAAO,WAAW,CAAC,CAAE,OAAQ,EAAA,iBAAgB,CAAG,OAAA,EAAQ,QAAA,CAAQ,EAAG,IACrE,EAEa,EAAa,CAAC,EAAe,GAAG,KAC3C,QAAQ,GAAG,CAAC,qCAAkB,KAAY,EAC5C,EAEa,EAAe,CAAC,EAAe,GAAG,KAC7C,QAAQ,KAAK,CAAC,qCAAkB,KAAY,EAC9C,EAEa,EAAiB,KAC5B,QAAQ,GAAG,CAAC,CAAC,iEAAuB,EAAE,EAAA,OAAM,CAAE,IAAI,EAAE,EAAA,SAAQ,CAAE,CAAC,CAAE,iBACnE,C,G,E,Q,S,C,C,C,EC1BA,EAAA,OAAA,CAAiB,KAAK,KAAK,CAAC,qpC,G,I,E,E,S,E,E,S,E,C,EWCxB,EAAU,EAAiB,CAAC,EAUhC,SAAS,IACL,MAAM,AAAI,MAAM,kCACpB,CACA,SAAS,IACL,MAAM,AAAI,MAAM,oCACpB,CAqBA,SAAS,EAAW,CAAG,EACnB,GAAI,IAAqB,WAErB,OAAO,WAAW,EAAK,GAG3B,GAAK,AAAA,CAAA,IAAqB,GAAoB,CAAC,CAAA,G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","sources":["<anon>","src/utils/constant.ts","src/utils/index.ts","package.json","src/helper.ts","src/utils/dom.ts","node_modules/html-to-image/es/index.js","node_modules/html-to-image/src/index.ts","node_modules/html-to-image/es/clone-node.js","node_modules/html-to-image/src/clone-node.ts","node_modules/html-to-image/es/clone-pseudos.js","node_modules/html-to-image/src/clone-pseudos.ts","node_modules/html-to-image/es/util.js","node_modules/html-to-image/src/util.ts","node_modules/process/browser.js","node_modules/html-to-image/es/mimes.js","node_modules/html-to-image/src/mimes.ts","node_modules/html-to-image/es/dataurl.js","node_modules/html-to-image/src/dataurl.ts","node_modules/html-to-image/es/embed-images.js","node_modules/html-to-image/src/embed-images.ts","node_modules/html-to-image/es/embed-resources.js","node_modules/html-to-image/src/embed-resources.ts","node_modules/html-to-image/es/apply-style.js","node_modules/html-to-image/src/apply-style.ts","node_modules/html-to-image/es/embed-webfonts.js","node_modules/html-to-image/src/embed-webfonts.ts"],"sourcesContent":["(() => {\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequiree62f\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequiree62f\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"d0TNe\", function(module, exports) {\n\n$parcel$export(module.exports, \"DOM_SHOT_EXT_NAME\", () => $b6370854aea1ab9c$export$14333815d08d1368);\n$parcel$export(module.exports, \"DOM_SHOT_EXT_BG_NAME\", () => $b6370854aea1ab9c$export$1626c9497abbc183);\n$parcel$export(module.exports, \"DOM_SHOT_EXT_ACTION\", () => $b6370854aea1ab9c$export$87e24ddbab2613d9);\nconst $b6370854aea1ab9c$export$14333815d08d1368 = \"dom_shot_chrome_extension\";\nconst $b6370854aea1ab9c$export$1626c9497abbc183 = \"dom_shot_chrome_extension_bg\";\nvar $b6370854aea1ab9c$export$87e24ddbab2613d9;\n(function(DOM_SHOT_EXT_ACTION) {\n    DOM_SHOT_EXT_ACTION[DOM_SHOT_EXT_ACTION[\"ready\"] = 0] = \"ready\";\n    DOM_SHOT_EXT_ACTION[DOM_SHOT_EXT_ACTION[\"domShot\"] = 1] = \"domShot\";\n})($b6370854aea1ab9c$export$87e24ddbab2613d9 || ($b6370854aea1ab9c$export$87e24ddbab2613d9 = {}));\n\n});\n\nparcelRegister(\"afMVx\", function(module, exports) {\n\n$parcel$export(module.exports, \"doDomShotAction\", () => $c498bb1c05d876ef$export$c2baa37b6f53c8a6);\n$parcel$export(module.exports, \"domShotLog\", () => $c498bb1c05d876ef$export$3c628e933563550d);\n$parcel$export(module.exports, \"domShotError\", () => $c498bb1c05d876ef$export$3ff6e4654a09dfa4);\n$parcel$export(module.exports, \"domShotVersion\", () => $c498bb1c05d876ef$export$a2b6a13999826ac7);\n\nvar $d0TNe = parcelRequire(\"d0TNe\");\n\nvar $hsKA8 = parcelRequire(\"hsKA8\");\nconst $c498bb1c05d876ef$export$40edfb7eeb78c4e8 = ()=>{\n    return false;\n};\nconst $c498bb1c05d876ef$export$edd07609368c8939 = async (timeout = 0)=>{\n    return new Promise((resolve)=>setTimeout(()=>resolve(true), timeout));\n};\nconst $c498bb1c05d876ef$export$c2baa37b6f53c8a6 = (action, payload)=>{\n    console.log(\"[dodo] \", \"postmessage\");\n    window.postMessage({\n        source: (0, $d0TNe.DOM_SHOT_EXT_NAME),\n        action: action,\n        payload: payload\n    }, \"*\");\n};\nconst $c498bb1c05d876ef$export$3c628e933563550d = (message, ...optionalParams)=>{\n    console.log(\"[\\uD83D\\uDD38DOM_SHOT\\uD83D\\uDD38]\", message, ...optionalParams);\n};\nconst $c498bb1c05d876ef$export$3ff6e4654a09dfa4 = (message, ...optionalParams)=>{\n    console.error(\"[\\uD83D\\uDD38DOM_SHOT\\uD83D\\uDD38]\", message, ...optionalParams);\n};\nconst $c498bb1c05d876ef$export$a2b6a13999826ac7 = ()=>{\n    console.log(`[\\u{1F538}DOM_SHOT\\u{1F538}] \\u{63D2}\\u{4EF6}\\u{7248}\\u{672C}%c v${(0, $hsKA8.version)} at ${(0, $hsKA8.buildTime)}`, \"color: orange;\");\n};\n\n});\nparcelRegister(\"hsKA8\", function(module, exports) {\nmodule.exports = JSON.parse('{\"name\":\"dom-shot-chrome-extension\",\"version\":\"0.1.4\",\"buildTime\":\"2024-08-09\",\"source\":\"src/index.html\",\"description\":\"dom-shot-chrome-extension\",\"dependencies\":{\"clsx\":\"^1.2.1\",\"dayjs\":\"^1.11.7\",\"html-to-image\":\"^1.11.11\",\"mobx\":\"^6.12.3\",\"react\":\"^18.2.0\",\"react-dom\":\"^18.2.0\",\"react-draggable\":\"^4.4.6\",\"react-select\":\"^5.7.7\"},\"devDependencies\":{\"@parcel/transformer-less\":\"^2.9.3\",\"@types/node\":\"^20.6.5\",\"@types/react\":\"18.0\",\"@types/react-dom\":\"18.0\",\"chrome-types\":\"^0.1.231\",\"html2canvas\":\"^1.4.1\",\"parcel\":\"^2.8.3\",\"postcss\":\"^8.4.30\",\"postcss-modules\":\"^4.3.1\",\"process\":\"^0.11.10\"},\"scripts\":{\"start\":\"parcel src/index.tsx src/popup.html  --no-cache\",\"start:bg\":\"parcel build src/background.ts --no-cache\",\"build\":\"rm -rf dist/; parcel build src/background.ts src/helper.ts src/index.tsx src/devtools.html src/sidebar.html --no-content-hash --no-cache;sh deploy.sh\",\"test\":\"echo \\\\\"Error: no test specified\\\\\" && exit 1\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/DearDawn/dom-shot.git\"},\"keywords\":[],\"author\":\"\",\"license\":\"ISC\",\"bugs\":{\"url\":\"https://github.com/DearDawn/dom-shot/issues\"},\"homepage\":\"https://github.com/DearDawn/dom-shot\"}');\n\n});\n\n\n\nvar $d0TNe = parcelRequire(\"d0TNe\");\n\nvar $afMVx = parcelRequire(\"afMVx\");\nvar $d3c1734dacb01657$exports = {};\n// shim for using process in browser\nvar $d3c1734dacb01657$var$process = $d3c1734dacb01657$exports = {};\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\nvar $d3c1734dacb01657$var$cachedSetTimeout;\nvar $d3c1734dacb01657$var$cachedClearTimeout;\nfunction $d3c1734dacb01657$var$defaultSetTimout() {\n    throw new Error(\"setTimeout has not been defined\");\n}\nfunction $d3c1734dacb01657$var$defaultClearTimeout() {\n    throw new Error(\"clearTimeout has not been defined\");\n}\n(function() {\n    try {\n        if (typeof setTimeout === \"function\") $d3c1734dacb01657$var$cachedSetTimeout = setTimeout;\n        else $d3c1734dacb01657$var$cachedSetTimeout = $d3c1734dacb01657$var$defaultSetTimout;\n    } catch (e) {\n        $d3c1734dacb01657$var$cachedSetTimeout = $d3c1734dacb01657$var$defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === \"function\") $d3c1734dacb01657$var$cachedClearTimeout = clearTimeout;\n        else $d3c1734dacb01657$var$cachedClearTimeout = $d3c1734dacb01657$var$defaultClearTimeout;\n    } catch (e) {\n        $d3c1734dacb01657$var$cachedClearTimeout = $d3c1734dacb01657$var$defaultClearTimeout;\n    }\n})();\nfunction $d3c1734dacb01657$var$runTimeout(fun) {\n    if ($d3c1734dacb01657$var$cachedSetTimeout === setTimeout) //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n    // if setTimeout wasn't available but was latter defined\n    if (($d3c1734dacb01657$var$cachedSetTimeout === $d3c1734dacb01657$var$defaultSetTimout || !$d3c1734dacb01657$var$cachedSetTimeout) && setTimeout) {\n        $d3c1734dacb01657$var$cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return $d3c1734dacb01657$var$cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return $d3c1734dacb01657$var$cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return $d3c1734dacb01657$var$cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction $d3c1734dacb01657$var$runClearTimeout(marker) {\n    if ($d3c1734dacb01657$var$cachedClearTimeout === clearTimeout) //normal enviroments in sane situations\n    return clearTimeout(marker);\n    // if clearTimeout wasn't available but was latter defined\n    if (($d3c1734dacb01657$var$cachedClearTimeout === $d3c1734dacb01657$var$defaultClearTimeout || !$d3c1734dacb01657$var$cachedClearTimeout) && clearTimeout) {\n        $d3c1734dacb01657$var$cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return $d3c1734dacb01657$var$cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return $d3c1734dacb01657$var$cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return $d3c1734dacb01657$var$cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar $d3c1734dacb01657$var$queue = [];\nvar $d3c1734dacb01657$var$draining = false;\nvar $d3c1734dacb01657$var$currentQueue;\nvar $d3c1734dacb01657$var$queueIndex = -1;\nfunction $d3c1734dacb01657$var$cleanUpNextTick() {\n    if (!$d3c1734dacb01657$var$draining || !$d3c1734dacb01657$var$currentQueue) return;\n    $d3c1734dacb01657$var$draining = false;\n    if ($d3c1734dacb01657$var$currentQueue.length) $d3c1734dacb01657$var$queue = $d3c1734dacb01657$var$currentQueue.concat($d3c1734dacb01657$var$queue);\n    else $d3c1734dacb01657$var$queueIndex = -1;\n    if ($d3c1734dacb01657$var$queue.length) $d3c1734dacb01657$var$drainQueue();\n}\nfunction $d3c1734dacb01657$var$drainQueue() {\n    if ($d3c1734dacb01657$var$draining) return;\n    var timeout = $d3c1734dacb01657$var$runTimeout($d3c1734dacb01657$var$cleanUpNextTick);\n    $d3c1734dacb01657$var$draining = true;\n    var len = $d3c1734dacb01657$var$queue.length;\n    while(len){\n        $d3c1734dacb01657$var$currentQueue = $d3c1734dacb01657$var$queue;\n        $d3c1734dacb01657$var$queue = [];\n        while(++$d3c1734dacb01657$var$queueIndex < len)if ($d3c1734dacb01657$var$currentQueue) $d3c1734dacb01657$var$currentQueue[$d3c1734dacb01657$var$queueIndex].run();\n        $d3c1734dacb01657$var$queueIndex = -1;\n        len = $d3c1734dacb01657$var$queue.length;\n    }\n    $d3c1734dacb01657$var$currentQueue = null;\n    $d3c1734dacb01657$var$draining = false;\n    $d3c1734dacb01657$var$runClearTimeout(timeout);\n}\n$d3c1734dacb01657$var$process.nextTick = function(fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];\n    $d3c1734dacb01657$var$queue.push(new $d3c1734dacb01657$var$Item(fun, args));\n    if ($d3c1734dacb01657$var$queue.length === 1 && !$d3c1734dacb01657$var$draining) $d3c1734dacb01657$var$runTimeout($d3c1734dacb01657$var$drainQueue);\n};\n// v8 likes predictible objects\nfunction $d3c1734dacb01657$var$Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\n$d3c1734dacb01657$var$Item.prototype.run = function() {\n    this.fun.apply(null, this.array);\n};\n$d3c1734dacb01657$var$process.title = \"browser\";\n$d3c1734dacb01657$var$process.browser = true;\n$d3c1734dacb01657$var$process.env = {};\n$d3c1734dacb01657$var$process.argv = [];\n$d3c1734dacb01657$var$process.version = \"\"; // empty string to avoid regexp issues\n$d3c1734dacb01657$var$process.versions = {};\nfunction $d3c1734dacb01657$var$noop() {}\n$d3c1734dacb01657$var$process.on = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.addListener = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.once = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.off = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.removeListener = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.removeAllListeners = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.emit = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.prependListener = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.prependOnceListener = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.listeners = function(name) {\n    return [];\n};\n$d3c1734dacb01657$var$process.binding = function(name) {\n    throw new Error(\"process.binding is not supported\");\n};\n$d3c1734dacb01657$var$process.cwd = function() {\n    return \"/\";\n};\n$d3c1734dacb01657$var$process.chdir = function(dir) {\n    throw new Error(\"process.chdir is not supported\");\n};\n$d3c1734dacb01657$var$process.umask = function() {\n    return 0;\n};\n\n\nfunction $3f38c4817eb4f38b$export$f85c16a6d62f7d63(url, baseUrl) {\n    // url is absolute already\n    if (url.match(/^[a-z]+:\\/\\//i)) return url;\n    // url is absolute already, without protocol\n    if (url.match(/^\\/\\//)) return window.location.protocol + url;\n    // dataURI, mailto:, tel:, etc.\n    if (url.match(/^[a-z]+:/i)) return url;\n    const doc = document.implementation.createHTMLDocument();\n    const base = doc.createElement(\"base\");\n    const a = doc.createElement(\"a\");\n    doc.head.appendChild(base);\n    doc.body.appendChild(a);\n    if (baseUrl) base.href = baseUrl;\n    a.href = url;\n    return a.href;\n}\nconst $3f38c4817eb4f38b$export$31b40729666a4ae0 = (()=>{\n    // generate uuid for className of pseudo elements.\n    // We should not use GUIDs, otherwise pseudo elements sometimes cannot be captured.\n    let counter = 0;\n    // ref: http://stackoverflow.com/a/6248722/2519373\n    const random = ()=>// eslint-disable-next-line no-bitwise\n        `0000${(Math.random() * 36 ** 4 << 0).toString(36)}`.slice(-4);\n    return ()=>{\n        counter += 1;\n        return `u${random()}${counter}`;\n    };\n})();\nfunction $3f38c4817eb4f38b$export$1391212d75b2ee65(ms) {\n    return (args)=>new Promise((resolve)=>{\n            setTimeout(()=>resolve(args), ms);\n        });\n}\nfunction $3f38c4817eb4f38b$export$45b10814cc054894(arrayLike) {\n    const arr = [];\n    for(let i = 0, l = arrayLike.length; i < l; i++)arr.push(arrayLike[i]);\n    return arr;\n}\nfunction $3f38c4817eb4f38b$var$px(node, styleProperty) {\n    const win = node.ownerDocument.defaultView || window;\n    const val = win.getComputedStyle(node).getPropertyValue(styleProperty);\n    return val ? parseFloat(val.replace(\"px\", \"\")) : 0;\n}\nfunction $3f38c4817eb4f38b$var$getNodeWidth(node) {\n    const leftBorder = $3f38c4817eb4f38b$var$px(node, \"border-left-width\");\n    const rightBorder = $3f38c4817eb4f38b$var$px(node, \"border-right-width\");\n    return node.clientWidth + leftBorder + rightBorder;\n}\nfunction $3f38c4817eb4f38b$var$getNodeHeight(node) {\n    const topBorder = $3f38c4817eb4f38b$var$px(node, \"border-top-width\");\n    const bottomBorder = $3f38c4817eb4f38b$var$px(node, \"border-bottom-width\");\n    return node.clientHeight + topBorder + bottomBorder;\n}\nfunction $3f38c4817eb4f38b$export$ada5537b2c061996(targetNode, options = {}) {\n    const width = options.width || $3f38c4817eb4f38b$var$getNodeWidth(targetNode);\n    const height = options.height || $3f38c4817eb4f38b$var$getNodeHeight(targetNode);\n    return {\n        width: width,\n        height: height\n    };\n}\nfunction $3f38c4817eb4f38b$export$d39ce20a37bba061() {\n    let ratio;\n    let FINAL_PROCESS;\n    try {\n        FINAL_PROCESS = $d3c1734dacb01657$exports;\n    } catch (e) {\n    // pass\n    }\n    const val = FINAL_PROCESS && FINAL_PROCESS.env ? FINAL_PROCESS.env.devicePixelRatio : null;\n    if (val) {\n        ratio = parseInt(val, 10);\n        if (Number.isNaN(ratio)) ratio = 1;\n    }\n    return ratio || window.devicePixelRatio || 1;\n}\n// @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas#maximum_canvas_size\nconst $3f38c4817eb4f38b$var$canvasDimensionLimit = 16384;\nfunction $3f38c4817eb4f38b$export$c2c809a2fe6b0f1a(canvas) {\n    if (canvas.width > $3f38c4817eb4f38b$var$canvasDimensionLimit || canvas.height > $3f38c4817eb4f38b$var$canvasDimensionLimit) {\n        if (canvas.width > $3f38c4817eb4f38b$var$canvasDimensionLimit && canvas.height > $3f38c4817eb4f38b$var$canvasDimensionLimit) {\n            if (canvas.width > canvas.height) {\n                canvas.height *= $3f38c4817eb4f38b$var$canvasDimensionLimit / canvas.width;\n                canvas.width = $3f38c4817eb4f38b$var$canvasDimensionLimit;\n            } else {\n                canvas.width *= $3f38c4817eb4f38b$var$canvasDimensionLimit / canvas.height;\n                canvas.height = $3f38c4817eb4f38b$var$canvasDimensionLimit;\n            }\n        } else if (canvas.width > $3f38c4817eb4f38b$var$canvasDimensionLimit) {\n            canvas.height *= $3f38c4817eb4f38b$var$canvasDimensionLimit / canvas.width;\n            canvas.width = $3f38c4817eb4f38b$var$canvasDimensionLimit;\n        } else {\n            canvas.width *= $3f38c4817eb4f38b$var$canvasDimensionLimit / canvas.height;\n            canvas.height = $3f38c4817eb4f38b$var$canvasDimensionLimit;\n        }\n    }\n}\nfunction $3f38c4817eb4f38b$export$403d539f215df596(canvas, options = {}) {\n    if (canvas.toBlob) return new Promise((resolve)=>{\n        canvas.toBlob(resolve, options.type ? options.type : \"image/png\", options.quality ? options.quality : 1);\n    });\n    return new Promise((resolve)=>{\n        const binaryString = window.atob(canvas.toDataURL(options.type ? options.type : undefined, options.quality ? options.quality : undefined).split(\",\")[1]);\n        const len = binaryString.length;\n        const binaryArray = new Uint8Array(len);\n        for(let i = 0; i < len; i += 1)binaryArray[i] = binaryString.charCodeAt(i);\n        resolve(new Blob([\n            binaryArray\n        ], {\n            type: options.type ? options.type : \"image/png\"\n        }));\n    });\n}\nfunction $3f38c4817eb4f38b$export$ec664d7487540b(url) {\n    return new Promise((resolve, reject)=>{\n        const img = new Image();\n        img.decode = ()=>resolve(img);\n        img.onload = ()=>resolve(img);\n        img.onerror = reject;\n        img.crossOrigin = \"anonymous\";\n        img.decoding = \"async\";\n        img.src = url;\n    });\n}\nasync function $3f38c4817eb4f38b$export$fe77aa9c02de4599(svg) {\n    return Promise.resolve().then(()=>new XMLSerializer().serializeToString(svg)).then(encodeURIComponent).then((html)=>`data:image/svg+xml;charset=utf-8,${html}`);\n}\nasync function $3f38c4817eb4f38b$export$b62810fb8ca515fa(node, width, height) {\n    const xmlns = \"http://www.w3.org/2000/svg\";\n    const svg = document.createElementNS(xmlns, \"svg\");\n    const foreignObject = document.createElementNS(xmlns, \"foreignObject\");\n    svg.setAttribute(\"width\", `${width}`);\n    svg.setAttribute(\"height\", `${height}`);\n    svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n    foreignObject.setAttribute(\"width\", \"100%\");\n    foreignObject.setAttribute(\"height\", \"100%\");\n    foreignObject.setAttribute(\"x\", \"0\");\n    foreignObject.setAttribute(\"y\", \"0\");\n    foreignObject.setAttribute(\"externalResourcesRequired\", \"true\");\n    svg.appendChild(foreignObject);\n    foreignObject.appendChild(node);\n    return $3f38c4817eb4f38b$export$fe77aa9c02de4599(svg);\n}\nconst $3f38c4817eb4f38b$export$3a92fc9ec83ef360 = (node, instance)=>{\n    if (node instanceof instance) return true;\n    const nodePrototype = Object.getPrototypeOf(node);\n    if (nodePrototype === null) return false;\n    return nodePrototype.constructor.name === instance.name || $3f38c4817eb4f38b$export$3a92fc9ec83ef360(nodePrototype, instance);\n};\n\n\nfunction $5dc335fc18f5c31c$var$formatCSSText(style) {\n    const content = style.getPropertyValue(\"content\");\n    return `${style.cssText} content: '${content.replace(/'|\"/g, \"\")}';`;\n}\nfunction $5dc335fc18f5c31c$var$formatCSSProperties(style) {\n    return (0, $3f38c4817eb4f38b$export$45b10814cc054894)(style).map((name)=>{\n        const value = style.getPropertyValue(name);\n        const priority = style.getPropertyPriority(name);\n        return `${name}: ${value}${priority ? \" !important\" : \"\"};`;\n    }).join(\" \");\n}\nfunction $5dc335fc18f5c31c$var$getPseudoElementStyle(className, pseudo, style) {\n    const selector = `.${className}:${pseudo}`;\n    const cssText = style.cssText ? $5dc335fc18f5c31c$var$formatCSSText(style) : $5dc335fc18f5c31c$var$formatCSSProperties(style);\n    return document.createTextNode(`${selector}{${cssText}}`);\n}\nfunction $5dc335fc18f5c31c$var$clonePseudoElement(nativeNode, clonedNode, pseudo) {\n    const style = window.getComputedStyle(nativeNode, pseudo);\n    const content = style.getPropertyValue(\"content\");\n    if (content === \"\" || content === \"none\") return;\n    const className = (0, $3f38c4817eb4f38b$export$31b40729666a4ae0)();\n    try {\n        clonedNode.className = `${clonedNode.className} ${className}`;\n    } catch (err) {\n        return;\n    }\n    const styleElement = document.createElement(\"style\");\n    styleElement.appendChild($5dc335fc18f5c31c$var$getPseudoElementStyle(className, pseudo, style));\n    clonedNode.appendChild(styleElement);\n}\nfunction $5dc335fc18f5c31c$export$8df63687a708ed2e(nativeNode, clonedNode) {\n    $5dc335fc18f5c31c$var$clonePseudoElement(nativeNode, clonedNode, \":before\");\n    $5dc335fc18f5c31c$var$clonePseudoElement(nativeNode, clonedNode, \":after\");\n}\n\n\n\nconst $932a96ce56c3bc50$var$WOFF = \"application/font-woff\";\nconst $932a96ce56c3bc50$var$JPEG = \"image/jpeg\";\nconst $932a96ce56c3bc50$var$mimes = {\n    woff: $932a96ce56c3bc50$var$WOFF,\n    woff2: $932a96ce56c3bc50$var$WOFF,\n    ttf: \"application/font-truetype\",\n    eot: \"application/vnd.ms-fontobject\",\n    png: \"image/png\",\n    jpg: $932a96ce56c3bc50$var$JPEG,\n    jpeg: $932a96ce56c3bc50$var$JPEG,\n    gif: \"image/gif\",\n    tiff: \"image/tiff\",\n    svg: \"image/svg+xml\",\n    webp: \"image/webp\"\n};\nfunction $932a96ce56c3bc50$var$getExtension(url) {\n    const match = /\\.([^./]*?)$/g.exec(url);\n    return match ? match[1] : \"\";\n}\nfunction $932a96ce56c3bc50$export$200548c990602f61(url) {\n    const extension = $932a96ce56c3bc50$var$getExtension(url).toLowerCase();\n    return $932a96ce56c3bc50$var$mimes[extension] || \"\";\n}\n\n\nfunction $36f8c7f53bd1328c$var$getContentFromDataUrl(dataURL) {\n    return dataURL.split(/,/)[1];\n}\nfunction $36f8c7f53bd1328c$export$f8a05efa20ffd5a(url) {\n    return url.search(/^(data:)/) !== -1;\n}\nfunction $36f8c7f53bd1328c$export$68336ea1617fa80a(content, mimeType) {\n    return `data:${mimeType};base64,${content}`;\n}\nasync function $36f8c7f53bd1328c$export$c20a8b76c95b0d41(url, init, process) {\n    const res = await fetch(url, init);\n    if (res.status === 404) throw new Error(`Resource \"${res.url}\" not found`);\n    const blob = await res.blob();\n    return new Promise((resolve, reject)=>{\n        const reader = new FileReader();\n        reader.onerror = reject;\n        reader.onloadend = ()=>{\n            try {\n                resolve(process({\n                    res: res,\n                    result: reader.result\n                }));\n            } catch (error) {\n                reject(error);\n            }\n        };\n        reader.readAsDataURL(blob);\n    });\n}\nconst $36f8c7f53bd1328c$var$cache = {};\nfunction $36f8c7f53bd1328c$var$getCacheKey(url, contentType, includeQueryParams) {\n    let key = url.replace(/\\?.*/, \"\");\n    if (includeQueryParams) key = url;\n    // font resource\n    if (/ttf|otf|eot|woff2?/i.test(key)) key = key.replace(/.*\\//, \"\");\n    return contentType ? `[${contentType}]${key}` : key;\n}\nasync function $36f8c7f53bd1328c$export$bdf0422c029b202a(resourceUrl, contentType, options) {\n    const cacheKey = $36f8c7f53bd1328c$var$getCacheKey(resourceUrl, contentType, options.includeQueryParams);\n    if ($36f8c7f53bd1328c$var$cache[cacheKey] != null) return $36f8c7f53bd1328c$var$cache[cacheKey];\n    // ref: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache\n    if (options.cacheBust) // eslint-disable-next-line no-param-reassign\n    resourceUrl += (/\\?/.test(resourceUrl) ? \"&\" : \"?\") + new Date().getTime();\n    let dataURL;\n    try {\n        const content = await $36f8c7f53bd1328c$export$c20a8b76c95b0d41(resourceUrl, options.fetchRequestInit, ({ res: res, result: result })=>{\n            if (!contentType) // eslint-disable-next-line no-param-reassign\n            contentType = res.headers.get(\"Content-Type\") || \"\";\n            return $36f8c7f53bd1328c$var$getContentFromDataUrl(result);\n        });\n        dataURL = $36f8c7f53bd1328c$export$68336ea1617fa80a(content, contentType);\n    } catch (error) {\n        dataURL = options.imagePlaceholder || \"\";\n        let msg = `Failed to fetch resource: ${resourceUrl}`;\n        if (error) msg = typeof error === \"string\" ? error : error.message;\n        if (msg) console.warn(msg);\n    }\n    $36f8c7f53bd1328c$var$cache[cacheKey] = dataURL;\n    return dataURL;\n}\n\n\nasync function $e4993691940aed80$var$cloneCanvasElement(canvas) {\n    const dataURL = canvas.toDataURL();\n    if (dataURL === \"data:,\") return canvas.cloneNode(false);\n    return (0, $3f38c4817eb4f38b$export$ec664d7487540b)(dataURL);\n}\nasync function $e4993691940aed80$var$cloneVideoElement(video, options) {\n    if (video.currentSrc) {\n        const canvas = document.createElement(\"canvas\");\n        const ctx = canvas.getContext(\"2d\");\n        canvas.width = video.clientWidth;\n        canvas.height = video.clientHeight;\n        ctx === null || ctx === void 0 || ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n        const dataURL = canvas.toDataURL();\n        return (0, $3f38c4817eb4f38b$export$ec664d7487540b)(dataURL);\n    }\n    const poster = video.poster;\n    const contentType = (0, $932a96ce56c3bc50$export$200548c990602f61)(poster);\n    const dataURL = await (0, $36f8c7f53bd1328c$export$bdf0422c029b202a)(poster, contentType, options);\n    return (0, $3f38c4817eb4f38b$export$ec664d7487540b)(dataURL);\n}\nasync function $e4993691940aed80$var$cloneIFrameElement(iframe) {\n    var _a;\n    try {\n        if ((_a = iframe === null || iframe === void 0 ? void 0 : iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.body) return await $e4993691940aed80$export$ae8e35ea29ddac22(iframe.contentDocument.body, {}, true);\n    } catch (_b) {\n    // Failed to clone iframe\n    }\n    return iframe.cloneNode(false);\n}\nasync function $e4993691940aed80$var$cloneSingleNode(node, options) {\n    if ((0, $3f38c4817eb4f38b$export$3a92fc9ec83ef360)(node, HTMLCanvasElement)) return $e4993691940aed80$var$cloneCanvasElement(node);\n    if ((0, $3f38c4817eb4f38b$export$3a92fc9ec83ef360)(node, HTMLVideoElement)) return $e4993691940aed80$var$cloneVideoElement(node, options);\n    if ((0, $3f38c4817eb4f38b$export$3a92fc9ec83ef360)(node, HTMLIFrameElement)) return $e4993691940aed80$var$cloneIFrameElement(node);\n    return node.cloneNode(false);\n}\nconst $e4993691940aed80$var$isSlotElement = (node)=>node.tagName != null && node.tagName.toUpperCase() === \"SLOT\";\nasync function $e4993691940aed80$var$cloneChildren(nativeNode, clonedNode, options) {\n    var _a, _b;\n    let children = [];\n    if ($e4993691940aed80$var$isSlotElement(nativeNode) && nativeNode.assignedNodes) children = (0, $3f38c4817eb4f38b$export$45b10814cc054894)(nativeNode.assignedNodes());\n    else if ((0, $3f38c4817eb4f38b$export$3a92fc9ec83ef360)(nativeNode, HTMLIFrameElement) && ((_a = nativeNode.contentDocument) === null || _a === void 0 ? void 0 : _a.body)) children = (0, $3f38c4817eb4f38b$export$45b10814cc054894)(nativeNode.contentDocument.body.childNodes);\n    else children = (0, $3f38c4817eb4f38b$export$45b10814cc054894)(((_b = nativeNode.shadowRoot) !== null && _b !== void 0 ? _b : nativeNode).childNodes);\n    if (children.length === 0 || (0, $3f38c4817eb4f38b$export$3a92fc9ec83ef360)(nativeNode, HTMLVideoElement)) return clonedNode;\n    await children.reduce((deferred, child)=>deferred.then(()=>$e4993691940aed80$export$ae8e35ea29ddac22(child, options)).then((clonedChild)=>{\n            if (clonedChild) clonedNode.appendChild(clonedChild);\n        }), Promise.resolve());\n    return clonedNode;\n}\nfunction $e4993691940aed80$var$cloneCSSStyle(nativeNode, clonedNode) {\n    const targetStyle = clonedNode.style;\n    if (!targetStyle) return;\n    const sourceStyle = window.getComputedStyle(nativeNode);\n    if (sourceStyle.cssText) {\n        targetStyle.cssText = sourceStyle.cssText;\n        targetStyle.transformOrigin = sourceStyle.transformOrigin;\n    } else (0, $3f38c4817eb4f38b$export$45b10814cc054894)(sourceStyle).forEach((name)=>{\n        let value = sourceStyle.getPropertyValue(name);\n        if (name === \"font-size\" && value.endsWith(\"px\")) {\n            const reducedFont = Math.floor(parseFloat(value.substring(0, value.length - 2))) - 0.1;\n            value = `${reducedFont}px`;\n        }\n        if ((0, $3f38c4817eb4f38b$export$3a92fc9ec83ef360)(nativeNode, HTMLIFrameElement) && name === \"display\" && value === \"inline\") value = \"block\";\n        if (name === \"d\" && clonedNode.getAttribute(\"d\")) value = `path(${clonedNode.getAttribute(\"d\")})`;\n        targetStyle.setProperty(name, value, sourceStyle.getPropertyPriority(name));\n    });\n}\nfunction $e4993691940aed80$var$cloneInputValue(nativeNode, clonedNode) {\n    if ((0, $3f38c4817eb4f38b$export$3a92fc9ec83ef360)(nativeNode, HTMLTextAreaElement)) clonedNode.innerHTML = nativeNode.value;\n    if ((0, $3f38c4817eb4f38b$export$3a92fc9ec83ef360)(nativeNode, HTMLInputElement)) clonedNode.setAttribute(\"value\", nativeNode.value);\n}\nfunction $e4993691940aed80$var$cloneSelectValue(nativeNode, clonedNode) {\n    if ((0, $3f38c4817eb4f38b$export$3a92fc9ec83ef360)(nativeNode, HTMLSelectElement)) {\n        const clonedSelect = clonedNode;\n        const selectedOption = Array.from(clonedSelect.children).find((child)=>nativeNode.value === child.getAttribute(\"value\"));\n        if (selectedOption) selectedOption.setAttribute(\"selected\", \"\");\n    }\n}\nfunction $e4993691940aed80$var$decorate(nativeNode, clonedNode) {\n    if ((0, $3f38c4817eb4f38b$export$3a92fc9ec83ef360)(clonedNode, Element)) {\n        $e4993691940aed80$var$cloneCSSStyle(nativeNode, clonedNode);\n        (0, $5dc335fc18f5c31c$export$8df63687a708ed2e)(nativeNode, clonedNode);\n        $e4993691940aed80$var$cloneInputValue(nativeNode, clonedNode);\n        $e4993691940aed80$var$cloneSelectValue(nativeNode, clonedNode);\n    }\n    return clonedNode;\n}\nasync function $e4993691940aed80$var$ensureSVGSymbols(clone, options) {\n    const uses = clone.querySelectorAll ? clone.querySelectorAll(\"use\") : [];\n    if (uses.length === 0) return clone;\n    const processedDefs = {};\n    for(let i = 0; i < uses.length; i++){\n        const use = uses[i];\n        const id = use.getAttribute(\"xlink:href\");\n        if (id) {\n            const exist = clone.querySelector(id);\n            const definition = document.querySelector(id);\n            if (!exist && definition && !processedDefs[id]) // eslint-disable-next-line no-await-in-loop\n            processedDefs[id] = await $e4993691940aed80$export$ae8e35ea29ddac22(definition, options, true);\n        }\n    }\n    const nodes = Object.values(processedDefs);\n    if (nodes.length) {\n        const ns = \"http://www.w3.org/1999/xhtml\";\n        const svg = document.createElementNS(ns, \"svg\");\n        svg.setAttribute(\"xmlns\", ns);\n        svg.style.position = \"absolute\";\n        svg.style.width = \"0\";\n        svg.style.height = \"0\";\n        svg.style.overflow = \"hidden\";\n        svg.style.display = \"none\";\n        const defs = document.createElementNS(ns, \"defs\");\n        svg.appendChild(defs);\n        for(let i = 0; i < nodes.length; i++)defs.appendChild(nodes[i]);\n        clone.appendChild(svg);\n    }\n    return clone;\n}\nasync function $e4993691940aed80$export$ae8e35ea29ddac22(node, options, isRoot) {\n    if (!isRoot && options.filter && !options.filter(node)) return null;\n    return Promise.resolve(node).then((clonedNode)=>$e4993691940aed80$var$cloneSingleNode(clonedNode, options)).then((clonedNode)=>$e4993691940aed80$var$cloneChildren(node, clonedNode, options)).then((clonedNode)=>$e4993691940aed80$var$decorate(node, clonedNode)).then((clonedNode)=>$e4993691940aed80$var$ensureSVGSymbols(clonedNode, options));\n}\n\n\n\n\n\nconst $6f23389cdbe0dece$var$URL_REGEX = /url\\((['\"]?)([^'\"]+?)\\1\\)/g;\nconst $6f23389cdbe0dece$var$URL_WITH_FORMAT_REGEX = /url\\([^)]+\\)\\s*format\\(([\"']?)([^\"']+)\\1\\)/g;\nconst $6f23389cdbe0dece$var$FONT_SRC_REGEX = /src:\\s*(?:url\\([^)]+\\)\\s*format\\([^)]+\\)[,;]\\s*)+/g;\nfunction $6f23389cdbe0dece$var$toRegex(url) {\n    // eslint-disable-next-line no-useless-escape\n    const escaped = url.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, \"\\\\$1\");\n    return new RegExp(`(url\\\\(['\"]?)(${escaped})(['\"]?\\\\))`, \"g\");\n}\nfunction $6f23389cdbe0dece$export$d04549d631b8762d(cssText) {\n    const urls = [];\n    cssText.replace($6f23389cdbe0dece$var$URL_REGEX, (raw, quotation, url)=>{\n        urls.push(url);\n        return raw;\n    });\n    return urls.filter((url)=>!(0, $36f8c7f53bd1328c$export$f8a05efa20ffd5a)(url));\n}\nasync function $6f23389cdbe0dece$export$2be46bb7e96db87f(cssText, resourceURL, baseURL, options, getContentFromUrl) {\n    try {\n        const resolvedURL = baseURL ? (0, $3f38c4817eb4f38b$export$f85c16a6d62f7d63)(resourceURL, baseURL) : resourceURL;\n        const contentType = (0, $932a96ce56c3bc50$export$200548c990602f61)(resourceURL);\n        let dataURL;\n        if (getContentFromUrl) {\n            const content = await getContentFromUrl(resolvedURL);\n            dataURL = (0, $36f8c7f53bd1328c$export$68336ea1617fa80a)(content, contentType);\n        } else dataURL = await (0, $36f8c7f53bd1328c$export$bdf0422c029b202a)(resolvedURL, contentType, options);\n        return cssText.replace($6f23389cdbe0dece$var$toRegex(resourceURL), `$1${dataURL}$3`);\n    } catch (error) {\n    // pass\n    }\n    return cssText;\n}\nfunction $6f23389cdbe0dece$var$filterPreferredFontFormat(str, { preferredFontFormat: preferredFontFormat }) {\n    return !preferredFontFormat ? str : str.replace($6f23389cdbe0dece$var$FONT_SRC_REGEX, (match)=>{\n        // eslint-disable-next-line no-constant-condition\n        while(true){\n            const [src, , format] = $6f23389cdbe0dece$var$URL_WITH_FORMAT_REGEX.exec(match) || [];\n            if (!format) return \"\";\n            if (format === preferredFontFormat) return `src: ${src};`;\n        }\n    });\n}\nfunction $6f23389cdbe0dece$export$7b668369e5eab853(url) {\n    return url.search($6f23389cdbe0dece$var$URL_REGEX) !== -1;\n}\nasync function $6f23389cdbe0dece$export$3d88803585cbbc21(cssText, baseUrl, options) {\n    if (!$6f23389cdbe0dece$export$7b668369e5eab853(cssText)) return cssText;\n    const filteredCSSText = $6f23389cdbe0dece$var$filterPreferredFontFormat(cssText, options);\n    const urls = $6f23389cdbe0dece$export$d04549d631b8762d(filteredCSSText);\n    return urls.reduce((deferred, url)=>deferred.then((css)=>$6f23389cdbe0dece$export$2be46bb7e96db87f(css, url, baseUrl, options)), Promise.resolve(filteredCSSText));\n}\n\n\n\n\n\nasync function $d00e8710aa74d8f2$var$embedProp(propName, node, options) {\n    var _a;\n    const propValue = (_a = node.style) === null || _a === void 0 ? void 0 : _a.getPropertyValue(propName);\n    if (propValue) {\n        const cssString = await (0, $6f23389cdbe0dece$export$3d88803585cbbc21)(propValue, null, options);\n        node.style.setProperty(propName, cssString, node.style.getPropertyPriority(propName));\n        return true;\n    }\n    return false;\n}\nasync function $d00e8710aa74d8f2$var$embedBackground(clonedNode, options) {\n    if (!await $d00e8710aa74d8f2$var$embedProp(\"background\", clonedNode, options)) await $d00e8710aa74d8f2$var$embedProp(\"background-image\", clonedNode, options);\n    if (!await $d00e8710aa74d8f2$var$embedProp(\"mask\", clonedNode, options)) await $d00e8710aa74d8f2$var$embedProp(\"mask-image\", clonedNode, options);\n}\nasync function $d00e8710aa74d8f2$var$embedImageNode(clonedNode, options) {\n    const isImageElement = (0, $3f38c4817eb4f38b$export$3a92fc9ec83ef360)(clonedNode, HTMLImageElement);\n    if (!(isImageElement && !(0, $36f8c7f53bd1328c$export$f8a05efa20ffd5a)(clonedNode.src)) && !((0, $3f38c4817eb4f38b$export$3a92fc9ec83ef360)(clonedNode, SVGImageElement) && !(0, $36f8c7f53bd1328c$export$f8a05efa20ffd5a)(clonedNode.href.baseVal))) return;\n    const url = isImageElement ? clonedNode.src : clonedNode.href.baseVal;\n    const dataURL = await (0, $36f8c7f53bd1328c$export$bdf0422c029b202a)(url, (0, $932a96ce56c3bc50$export$200548c990602f61)(url), options);\n    await new Promise((resolve, reject)=>{\n        clonedNode.onload = resolve;\n        clonedNode.onerror = reject;\n        const image = clonedNode;\n        if (image.decode) image.decode = resolve;\n        if (image.loading === \"lazy\") image.loading = \"eager\";\n        if (isImageElement) {\n            clonedNode.srcset = \"\";\n            clonedNode.src = dataURL;\n        } else clonedNode.href.baseVal = dataURL;\n    });\n}\nasync function $d00e8710aa74d8f2$var$embedChildren(clonedNode, options) {\n    const children = (0, $3f38c4817eb4f38b$export$45b10814cc054894)(clonedNode.childNodes);\n    const deferreds = children.map((child)=>$d00e8710aa74d8f2$export$6660fa8dd20e53aa(child, options));\n    await Promise.all(deferreds).then(()=>clonedNode);\n}\nasync function $d00e8710aa74d8f2$export$6660fa8dd20e53aa(clonedNode, options) {\n    if ((0, $3f38c4817eb4f38b$export$3a92fc9ec83ef360)(clonedNode, Element)) {\n        await $d00e8710aa74d8f2$var$embedBackground(clonedNode, options);\n        await $d00e8710aa74d8f2$var$embedImageNode(clonedNode, options);\n        await $d00e8710aa74d8f2$var$embedChildren(clonedNode, options);\n    }\n}\n\n\nfunction $9466082ff3ed5bc2$export$d63a6b7859608045(node, options) {\n    const { style: style } = node;\n    if (options.backgroundColor) style.backgroundColor = options.backgroundColor;\n    if (options.width) style.width = `${options.width}px`;\n    if (options.height) style.height = `${options.height}px`;\n    const manual = options.style;\n    if (manual != null) Object.keys(manual).forEach((key)=>{\n        style[key] = manual[key];\n    });\n    return node;\n}\n\n\n\n\n\nconst $e00ffe9f0e6cf773$var$cssFetchCache = {};\nasync function $e00ffe9f0e6cf773$var$fetchCSS(url) {\n    let cache = $e00ffe9f0e6cf773$var$cssFetchCache[url];\n    if (cache != null) return cache;\n    const res = await fetch(url);\n    const cssText = await res.text();\n    cache = {\n        url: url,\n        cssText: cssText\n    };\n    $e00ffe9f0e6cf773$var$cssFetchCache[url] = cache;\n    return cache;\n}\nasync function $e00ffe9f0e6cf773$var$embedFonts(data, options) {\n    let cssText = data.cssText;\n    const regexUrl = /url\\([\"']?([^\"')]+)[\"']?\\)/g;\n    const fontLocs = cssText.match(/url\\([^)]+\\)/g) || [];\n    const loadFonts = fontLocs.map(async (loc)=>{\n        let url = loc.replace(regexUrl, \"$1\");\n        if (!url.startsWith(\"https://\")) url = new URL(url, data.url).href;\n        return (0, $36f8c7f53bd1328c$export$c20a8b76c95b0d41)(url, options.fetchRequestInit, ({ result: result })=>{\n            cssText = cssText.replace(loc, `url(${result})`);\n            return [\n                loc,\n                result\n            ];\n        });\n    });\n    return Promise.all(loadFonts).then(()=>cssText);\n}\nfunction $e00ffe9f0e6cf773$var$parseCSS(source) {\n    if (source == null) return [];\n    const result = [];\n    const commentsRegex = /(\\/\\*[\\s\\S]*?\\*\\/)/gi;\n    // strip out comments\n    let cssText = source.replace(commentsRegex, \"\");\n    // eslint-disable-next-line prefer-regex-literals\n    const keyframesRegex = new RegExp(\"((@.*?keyframes [\\\\s\\\\S]*?){([\\\\s\\\\S]*?}\\\\s*?)})\", \"gi\");\n    // eslint-disable-next-line no-constant-condition\n    while(true){\n        const matches = keyframesRegex.exec(cssText);\n        if (matches === null) break;\n        result.push(matches[0]);\n    }\n    cssText = cssText.replace(keyframesRegex, \"\");\n    const importRegex = /@import[\\s\\S]*?url\\([^)]*\\)[\\s\\S]*?;/gi;\n    // to match css & media queries together\n    const combinedCSSRegex = \"((\\\\s*?(?:\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/)?\\\\s*?@media[\\\\s\\\\S]*?){([\\\\s\\\\S]*?)}\\\\s*?})|(([\\\\s\\\\S]*?){([\\\\s\\\\S]*?)})\";\n    // unified regex\n    const unifiedRegex = new RegExp(combinedCSSRegex, \"gi\");\n    // eslint-disable-next-line no-constant-condition\n    while(true){\n        let matches = importRegex.exec(cssText);\n        if (matches === null) {\n            matches = unifiedRegex.exec(cssText);\n            if (matches === null) break;\n            else importRegex.lastIndex = unifiedRegex.lastIndex;\n        } else unifiedRegex.lastIndex = importRegex.lastIndex;\n        result.push(matches[0]);\n    }\n    return result;\n}\nasync function $e00ffe9f0e6cf773$var$getCSSRules(styleSheets, options) {\n    const ret = [];\n    const deferreds = [];\n    // First loop inlines imports\n    styleSheets.forEach((sheet)=>{\n        if (\"cssRules\" in sheet) try {\n            (0, $3f38c4817eb4f38b$export$45b10814cc054894)(sheet.cssRules || []).forEach((item, index)=>{\n                if (item.type === CSSRule.IMPORT_RULE) {\n                    let importIndex = index + 1;\n                    const url = item.href;\n                    const deferred = $e00ffe9f0e6cf773$var$fetchCSS(url).then((metadata)=>$e00ffe9f0e6cf773$var$embedFonts(metadata, options)).then((cssText)=>$e00ffe9f0e6cf773$var$parseCSS(cssText).forEach((rule)=>{\n                            try {\n                                sheet.insertRule(rule, rule.startsWith(\"@import\") ? importIndex += 1 : sheet.cssRules.length);\n                            } catch (error) {\n                                console.error(\"Error inserting rule from remote css\", {\n                                    rule: rule,\n                                    error: error\n                                });\n                            }\n                        })).catch((e)=>{\n                        console.error(\"Error loading remote css\", e.toString());\n                    });\n                    deferreds.push(deferred);\n                }\n            });\n        } catch (e) {\n            const inline = styleSheets.find((a)=>a.href == null) || document.styleSheets[0];\n            if (sheet.href != null) deferreds.push($e00ffe9f0e6cf773$var$fetchCSS(sheet.href).then((metadata)=>$e00ffe9f0e6cf773$var$embedFonts(metadata, options)).then((cssText)=>$e00ffe9f0e6cf773$var$parseCSS(cssText).forEach((rule)=>{\n                    inline.insertRule(rule, sheet.cssRules.length);\n                })).catch((err)=>{\n                console.error(\"Error loading remote stylesheet\", err);\n            }));\n            console.error(\"Error inlining remote css file\", e);\n        }\n    });\n    return Promise.all(deferreds).then(()=>{\n        // Second loop parses rules\n        styleSheets.forEach((sheet)=>{\n            if (\"cssRules\" in sheet) try {\n                (0, $3f38c4817eb4f38b$export$45b10814cc054894)(sheet.cssRules || []).forEach((item)=>{\n                    ret.push(item);\n                });\n            } catch (e) {\n                console.error(`Error while reading CSS rules from ${sheet.href}`, e);\n            }\n        });\n        return ret;\n    });\n}\nfunction $e00ffe9f0e6cf773$var$getWebFontRules(cssRules) {\n    return cssRules.filter((rule)=>rule.type === CSSRule.FONT_FACE_RULE).filter((rule)=>(0, $6f23389cdbe0dece$export$7b668369e5eab853)(rule.style.getPropertyValue(\"src\")));\n}\nasync function $e00ffe9f0e6cf773$var$parseWebFontRules(node, options) {\n    if (node.ownerDocument == null) throw new Error(\"Provided element is not within a Document\");\n    const styleSheets = (0, $3f38c4817eb4f38b$export$45b10814cc054894)(node.ownerDocument.styleSheets);\n    const cssRules = await $e00ffe9f0e6cf773$var$getCSSRules(styleSheets, options);\n    return $e00ffe9f0e6cf773$var$getWebFontRules(cssRules);\n}\nasync function $e00ffe9f0e6cf773$export$253c9aa3d83a57b6(node, options) {\n    const rules = await $e00ffe9f0e6cf773$var$parseWebFontRules(node, options);\n    const cssTexts = await Promise.all(rules.map((rule)=>{\n        const baseUrl = rule.parentStyleSheet ? rule.parentStyleSheet.href : null;\n        return (0, $6f23389cdbe0dece$export$3d88803585cbbc21)(rule.cssText, baseUrl, options);\n    }));\n    return cssTexts.join(\"\\n\");\n}\nasync function $e00ffe9f0e6cf773$export$2c2c83b77c8cb421(clonedNode, options) {\n    const cssText = options.fontEmbedCSS != null ? options.fontEmbedCSS : options.skipFonts ? null : await $e00ffe9f0e6cf773$export$253c9aa3d83a57b6(clonedNode, options);\n    if (cssText) {\n        const styleNode = document.createElement(\"style\");\n        const sytleContent = document.createTextNode(cssText);\n        styleNode.appendChild(sytleContent);\n        if (clonedNode.firstChild) clonedNode.insertBefore(styleNode, clonedNode.firstChild);\n        else clonedNode.appendChild(styleNode);\n    }\n}\n\n\n\nasync function $49e912db89b35827$export$20d300cb2d558b7(node, options = {}) {\n    const { width: width, height: height } = (0, $3f38c4817eb4f38b$export$ada5537b2c061996)(node, options);\n    const clonedNode = await (0, $e4993691940aed80$export$ae8e35ea29ddac22)(node, options, true);\n    await (0, $e00ffe9f0e6cf773$export$2c2c83b77c8cb421)(clonedNode, options);\n    await (0, $d00e8710aa74d8f2$export$6660fa8dd20e53aa)(clonedNode, options);\n    (0, $9466082ff3ed5bc2$export$d63a6b7859608045)(clonedNode, options);\n    const datauri = await (0, $3f38c4817eb4f38b$export$b62810fb8ca515fa)(clonedNode, width, height);\n    return datauri;\n}\nasync function $49e912db89b35827$export$f87f6982d1fd4f81(node, options = {}) {\n    const { width: width, height: height } = (0, $3f38c4817eb4f38b$export$ada5537b2c061996)(node, options);\n    const svg = await $49e912db89b35827$export$20d300cb2d558b7(node, options);\n    const img = await (0, $3f38c4817eb4f38b$export$ec664d7487540b)(svg);\n    const canvas = document.createElement(\"canvas\");\n    const context = canvas.getContext(\"2d\");\n    const ratio = options.pixelRatio || (0, $3f38c4817eb4f38b$export$d39ce20a37bba061)();\n    const canvasWidth = options.canvasWidth || width;\n    const canvasHeight = options.canvasHeight || height;\n    canvas.width = canvasWidth * ratio;\n    canvas.height = canvasHeight * ratio;\n    if (!options.skipAutoScale) (0, $3f38c4817eb4f38b$export$c2c809a2fe6b0f1a)(canvas);\n    canvas.style.width = `${canvasWidth}`;\n    canvas.style.height = `${canvasHeight}`;\n    if (options.backgroundColor) {\n        context.fillStyle = options.backgroundColor;\n        context.fillRect(0, 0, canvas.width, canvas.height);\n    }\n    context.drawImage(img, 0, 0, canvas.width, canvas.height);\n    return canvas;\n}\nasync function $49e912db89b35827$export$6f9e32581c0cde11(node, options = {}) {\n    const { width: width, height: height } = (0, $3f38c4817eb4f38b$export$ada5537b2c061996)(node, options);\n    const canvas = await $49e912db89b35827$export$f87f6982d1fd4f81(node, options);\n    const ctx = canvas.getContext(\"2d\");\n    return ctx.getImageData(0, 0, width, height).data;\n}\nasync function $49e912db89b35827$export$aba256f33615c92e(node, options = {}) {\n    const canvas = await $49e912db89b35827$export$f87f6982d1fd4f81(node, options);\n    return canvas.toDataURL();\n}\nasync function $49e912db89b35827$export$ed218bd2440d33a5(node, options = {}) {\n    const canvas = await $49e912db89b35827$export$f87f6982d1fd4f81(node, options);\n    return canvas.toDataURL(\"image/jpeg\", options.quality || 1);\n}\nasync function $49e912db89b35827$export$b20f4ee19ffa0668(node, options = {}) {\n    const canvas = await $49e912db89b35827$export$f87f6982d1fd4f81(node, options);\n    const blob = await (0, $3f38c4817eb4f38b$export$403d539f215df596)(canvas);\n    return blob;\n}\nasync function $49e912db89b35827$export$92678bad7eef403b(node, options = {}) {\n    return (0, $e00ffe9f0e6cf773$export$253c9aa3d83a57b6)(node, options);\n}\n\n\n\nvar $d0TNe = parcelRequire(\"d0TNe\");\n\nvar $afMVx = parcelRequire(\"afMVx\");\nconst $048c0dc54e08960c$export$4778991634f78fa5 = async ()=>{\n    (0, $afMVx.domShotLog)(\"\\u5F00\\u59CB\\u751F\\u6210\\u622A\\u56FE\");\n    const element = window[\"DOM_SHOT_EXT_DOM\"] || null;\n    if (!element) {\n        (0, $afMVx.domShotError)(\"\\u672A\\u627E\\u5230 DOM\");\n        return;\n    }\n    (0, $afMVx.domShotLog)(\"\\u56FE\\u50CF\\u5904\\u7406\\u4E2D...\");\n    await $048c0dc54e08960c$var$replaceImagesInDOM(element);\n    (0, $afMVx.domShotLog)(\"\\u5F00\\u59CB\\u622A\\u56FE...\");\n    (0, $49e912db89b35827$export$aba256f33615c92e)(element, {\n        backgroundColor: \"transparent\"\n    }).then((imgData)=>{\n        (0, $afMVx.domShotLog)(\"\\u622A\\u56FE\\u5B8C\\u6210\\uFF01\\uD83C\\uDF89\");\n        window.postMessage({\n            source: (0, $d0TNe.DOM_SHOT_EXT_BG_NAME),\n            action: (0, $d0TNe.DOM_SHOT_EXT_ACTION).domShot,\n            payload: imgData\n        }, \"*\");\n    }).catch(console.error);\n};\nasync function $048c0dc54e08960c$var$replaceImagesInDOM(domElement) {\n    // 获取所有 img 标签和包含背景图片的元素\n    let imgElements = Array.from(domElement.querySelectorAll(\"img\")).filter((element)=>!element.hasAttribute(\"data-dom-shot-replaced\"));\n    let bgElements = Array.from(domElement.querySelectorAll(\"*\")).filter((element)=>{\n        let backgroundImage = window.getComputedStyle(element).backgroundImage;\n        return backgroundImage && backgroundImage !== \"none\" && backgroundImage.startsWith(\"url\") && !element.hasAttribute(\"data-dom-shot-replaced\");\n    });\n    // 合并并去重\n    let elements = [\n        ...imgElements,\n        ...bgElements\n    ];\n    // 异步处理所有图像\n    await Promise.all(elements.map((element)=>{\n        if (element.tagName.toLowerCase() === \"img\") return $048c0dc54e08960c$var$replaceImage(element, element?.src);\n        else {\n            let backgroundImage = window.getComputedStyle(element).backgroundImage;\n            let url = backgroundImage.match(/url\\(\"?(.+?)\"?\\)/)[1];\n            return $048c0dc54e08960c$var$replaceImage(element, url);\n        }\n    }));\n}\nfunction $048c0dc54e08960c$var$replaceImage(element, url) {\n    return new Promise((resolve, reject)=>{\n        let imgElement = new Image();\n        imgElement.crossOrigin = \"anonymous\";\n        imgElement.onload = function() {\n            let canvas = document.createElement(\"canvas\");\n            canvas.width = imgElement.width;\n            canvas.height = imgElement.height;\n            let ctx = canvas.getContext(\"2d\");\n            ctx.drawImage(imgElement, 0, 0);\n            let dataURL = canvas.toDataURL(\"image/png\");\n            if (element.tagName.toLowerCase() === \"img\") element.src = dataURL; // 替换 img 标签的 src 属性\n            else element.style.backgroundImage = `url(${dataURL})`; // 替换背景图片\n            element.setAttribute(\"data-dom-shot-replaced\", \"true\"); // 添加标记\n            resolve(true);\n        };\n        imgElement.onerror = reject;\n        imgElement.src = url;\n    });\n}\n\n\nclass $24add57b2feb7361$var$Helper {\n    constructor(tabId){\n        this.clearEvent = ()=>{};\n        this.init = async ()=>{\n            this.clearEvent();\n            this.initUtils();\n        };\n        (0, $afMVx.domShotVersion)();\n        this.tabId = tabId || 0;\n    }\n    initUtils() {\n        const messageHandler = async (event)=>{\n            if (event?.data?.source !== (0, $d0TNe.DOM_SHOT_EXT_NAME)) return;\n            const { action: action } = event.data || {};\n            this.utilsActionMap[action]?.();\n        };\n        this.clearEvent = ()=>{\n            window.removeEventListener(\"message\", messageHandler);\n            window.removeEventListener(\"beforeunload\", this.clearEvent);\n        };\n        window.addEventListener(\"message\", messageHandler);\n        window.addEventListener(\"beforeunload\", this.clearEvent);\n    }\n    get utilsActionMap() {\n        return {\n            /** 给 DOM 截图，保留透明色 */ [(0, $d0TNe.DOM_SHOT_EXT_ACTION).domShot]: (0, $048c0dc54e08960c$export$4778991634f78fa5)\n        };\n    }\n}\nconst $24add57b2feb7361$var$DOM_SHOT_HELPER_KEY = \"dom_shot_ext_helper\";\nif (window[$24add57b2feb7361$var$DOM_SHOT_HELPER_KEY]) window[$24add57b2feb7361$var$DOM_SHOT_HELPER_KEY].init();\nelse {\n    const helper = new $24add57b2feb7361$var$Helper(...window[0, $d0TNe.DOM_SHOT_EXT_NAME]?.args || []);\n    window[$24add57b2feb7361$var$DOM_SHOT_HELPER_KEY] = helper;\n    helper.init();\n}\n\n})();\n//# sourceMappingURL=helper.js.map\n","export const DOM_SHOT_EXT_NAME = 'dom_shot_chrome_extension';\nexport const DOM_SHOT_EXT_BG_NAME = 'dom_shot_chrome_extension_bg';\n\nexport enum DOM_SHOT_EXT_ACTION {\n  ready,\n  domShot,\n};\n","import { DOM_SHOT_EXT_ACTION, DOM_SHOT_EXT_NAME } from \"./constant\";\nimport { version, buildTime } from '../../package.json';\n\nexport const isDev = () => {\n  return process.env.NODE_ENV === 'development';\n};\n\nexport const waitTime = async (timeout = 0) => {\n  return new Promise(resolve => setTimeout(() => resolve(true), timeout));\n};\n\nexport const doDomShotAction = (action: DOM_SHOT_EXT_ACTION, payload?: any) => {\n  console.log('[dodo] ', 'postmessage');\n  window.postMessage({ source: DOM_SHOT_EXT_NAME, action, payload }, '*');\n};\n\nexport const domShotLog = (message?: any, ...optionalParams: any[]) => {\n  console.log('[🔸DOM_SHOT🔸]', message, ...optionalParams);\n};\n\nexport const domShotError = (message?: any, ...optionalParams: any[]) => {\n  console.error('[🔸DOM_SHOT🔸]', message, ...optionalParams);\n};\n\nexport const domShotVersion = () => {\n  console.log(`[🔸DOM_SHOT🔸] 插件版本%c v${version} at ${buildTime}`, 'color: orange;');\n};\n","{\n  \"name\": \"dom-shot-chrome-extension\",\n  \"version\": \"0.1.4\",\n  \"buildTime\": \"2024-08-09\",\n  \"source\": \"src/index.html\",\n  \"description\": \"dom-shot-chrome-extension\",\n  \"dependencies\": {\n    \"clsx\": \"^1.2.1\",\n    \"dayjs\": \"^1.11.7\",\n    \"html-to-image\": \"^1.11.11\",\n    \"mobx\": \"^6.12.3\",\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\",\n    \"react-draggable\": \"^4.4.6\",\n    \"react-select\": \"^5.7.7\"\n  },\n  \"devDependencies\": {\n    \"@parcel/transformer-less\": \"^2.9.3\",\n    \"@types/node\": \"^20.6.5\",\n    \"@types/react\": \"18.0\",\n    \"@types/react-dom\": \"18.0\",\n    \"chrome-types\": \"^0.1.231\",\n    \"html2canvas\": \"^1.4.1\",\n    \"parcel\": \"^2.8.3\",\n    \"postcss\": \"^8.4.30\",\n    \"postcss-modules\": \"^4.3.1\",\n    \"process\": \"^0.11.10\"\n  },\n  \"scripts\": {\n    \"start\": \"parcel src/index.tsx src/popup.html  --no-cache\",\n    \"start:bg\": \"parcel build src/background.ts --no-cache\",\n    \"build\": \"rm -rf dist/; parcel build src/background.ts src/helper.ts src/index.tsx src/devtools.html src/sidebar.html --no-content-hash --no-cache;sh deploy.sh\",\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/DearDawn/dom-shot.git\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/DearDawn/dom-shot/issues\"\n  },\n  \"homepage\": \"https://github.com/DearDawn/dom-shot\"\n}\n","import { DOM_SHOT_EXT_ACTION, DOM_SHOT_EXT_NAME } from \"./utils/constant\";\nimport { domShotVersion } from \"./utils\";\nimport { shotDom } from \"./utils/dom\";\n\nclass Helper {\n  tabId: number;\n  constructor (tabId?: number) {\n    domShotVersion();\n    this.tabId = tabId || 0;\n  }\n\n  clearEvent = () => { };\n\n  init = async () => {\n    this.clearEvent();\n    this.initUtils();\n  };\n\n  initUtils () {\n    const messageHandler = async (event: MessageEvent<any>) => {\n      if (event?.data?.source !== DOM_SHOT_EXT_NAME) return;\n\n      const { action } = event.data || {};\n\n      this.utilsActionMap[action]?.();\n    };\n\n    this.clearEvent = () => {\n      window.removeEventListener('message', messageHandler);\n      window.removeEventListener('beforeunload', this.clearEvent);\n    };\n\n    window.addEventListener('message', messageHandler);\n    window.addEventListener('beforeunload', this.clearEvent);\n  }\n\n  get utilsActionMap () {\n    return {\n      /** 给 DOM 截图，保留透明色 */\n      [DOM_SHOT_EXT_ACTION.domShot]: shotDom,\n    };\n  }\n}\n\nconst DOM_SHOT_HELPER_KEY = 'dom_shot_ext_helper';\nif (window[DOM_SHOT_HELPER_KEY]) {\n  window[DOM_SHOT_HELPER_KEY].init();\n} else {\n  const helper = new Helper(...(window[DOM_SHOT_EXT_NAME]?.args || []));\n  window[DOM_SHOT_HELPER_KEY] = helper;\n  helper.init();\n}\n","import { toPng } from 'html-to-image';\nimport { DOM_SHOT_EXT_ACTION, DOM_SHOT_EXT_BG_NAME } from './constant';\nimport { domShotError, domShotLog } from '.';\n\n/** 给 DOM 截图，保留透明色 */\nexport const shotDom = async () => {\n  domShotLog('开始生成截图');\n  const element = window['DOM_SHOT_EXT_DOM'] || null;\n\n  if (!element) {\n    domShotError('未找到 DOM');\n    return;\n  }\n\n  domShotLog('图像处理中...');\n  await replaceImagesInDOM(element);\n  domShotLog('开始截图...');\n\n  toPng(element, { backgroundColor: 'transparent' }).then(imgData => {\n    domShotLog('截图完成！🎉');\n    window.postMessage({\n      source: DOM_SHOT_EXT_BG_NAME,\n      action: DOM_SHOT_EXT_ACTION.domShot,\n      payload: imgData\n    }, '*');\n  }).catch(console.error);\n};\n\nasync function replaceImagesInDOM (domElement: HTMLDivElement) {\n  // 获取所有 img 标签和包含背景图片的元素\n  let imgElements = Array.from(domElement.querySelectorAll('img')).filter(element => !element.hasAttribute('data-dom-shot-replaced'));\n  let bgElements = Array.from(domElement.querySelectorAll('*')).filter(element => {\n    let backgroundImage = window.getComputedStyle(element).backgroundImage;\n    return backgroundImage && backgroundImage !== \"none\" && backgroundImage.startsWith('url') && !element.hasAttribute('data-dom-shot-replaced');\n  });\n\n  // 合并并去重\n  let elements = [...imgElements, ...bgElements];\n\n  // 异步处理所有图像\n  await Promise.all(elements.map(element => {\n    if (element.tagName.toLowerCase() === \"img\") {\n      return replaceImage(element, (element as HTMLImageElement)?.src);\n    } else {\n      let backgroundImage = window.getComputedStyle(element).backgroundImage;\n      let url = backgroundImage.match(/url\\(\"?(.+?)\"?\\)/)[1];\n      return replaceImage(element, url);\n    }\n  }));\n}\n\nfunction replaceImage (element: any, url) {\n  return new Promise((resolve, reject) => {\n    let imgElement = new Image();\n    imgElement.crossOrigin = \"anonymous\";\n    imgElement.onload = function () {\n      let canvas = document.createElement(\"canvas\");\n      canvas.width = imgElement.width;\n      canvas.height = imgElement.height;\n      let ctx = canvas.getContext(\"2d\");\n      ctx.drawImage(imgElement, 0, 0);\n      let dataURL = canvas.toDataURL(\"image/png\");\n      if (element.tagName.toLowerCase() === \"img\") {\n        element.src = dataURL; // 替换 img 标签的 src 属性\n      } else {\n        element.style.backgroundImage = `url(${dataURL})`; // 替换背景图片\n      }\n      element.setAttribute('data-dom-shot-replaced', 'true'); // 添加标记\n      resolve(true);\n    };\n    imgElement.onerror = reject;\n    imgElement.src = url;\n  });\n}\n","import { cloneNode } from './clone-node';\nimport { embedImages } from './embed-images';\nimport { applyStyle } from './apply-style';\nimport { embedWebFonts, getWebFontCSS } from './embed-webfonts';\nimport { getImageSize, getPixelRatio, createImage, canvasToBlob, nodeToDataURL, checkCanvasDimensions, } from './util';\nexport async function toSvg(node, options = {}) {\n    const { width, height } = getImageSize(node, options);\n    const clonedNode = (await cloneNode(node, options, true));\n    await embedWebFonts(clonedNode, options);\n    await embedImages(clonedNode, options);\n    applyStyle(clonedNode, options);\n    const datauri = await nodeToDataURL(clonedNode, width, height);\n    return datauri;\n}\nexport async function toCanvas(node, options = {}) {\n    const { width, height } = getImageSize(node, options);\n    const svg = await toSvg(node, options);\n    const img = await createImage(svg);\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n    const ratio = options.pixelRatio || getPixelRatio();\n    const canvasWidth = options.canvasWidth || width;\n    const canvasHeight = options.canvasHeight || height;\n    canvas.width = canvasWidth * ratio;\n    canvas.height = canvasHeight * ratio;\n    if (!options.skipAutoScale) {\n        checkCanvasDimensions(canvas);\n    }\n    canvas.style.width = `${canvasWidth}`;\n    canvas.style.height = `${canvasHeight}`;\n    if (options.backgroundColor) {\n        context.fillStyle = options.backgroundColor;\n        context.fillRect(0, 0, canvas.width, canvas.height);\n    }\n    context.drawImage(img, 0, 0, canvas.width, canvas.height);\n    return canvas;\n}\nexport async function toPixelData(node, options = {}) {\n    const { width, height } = getImageSize(node, options);\n    const canvas = await toCanvas(node, options);\n    const ctx = canvas.getContext('2d');\n    return ctx.getImageData(0, 0, width, height).data;\n}\nexport async function toPng(node, options = {}) {\n    const canvas = await toCanvas(node, options);\n    return canvas.toDataURL();\n}\nexport async function toJpeg(node, options = {}) {\n    const canvas = await toCanvas(node, options);\n    return canvas.toDataURL('image/jpeg', options.quality || 1);\n}\nexport async function toBlob(node, options = {}) {\n    const canvas = await toCanvas(node, options);\n    const blob = await canvasToBlob(canvas);\n    return blob;\n}\nexport async function getFontEmbedCSS(node, options = {}) {\n    return getWebFontCSS(node, options);\n}\n//# sourceMappingURL=index.js.map","import { Options } from './types'\nimport { cloneNode } from './clone-node'\nimport { embedImages } from './embed-images'\nimport { applyStyle } from './apply-style'\nimport { embedWebFonts, getWebFontCSS } from './embed-webfonts'\nimport {\n  getImageSize,\n  getPixelRatio,\n  createImage,\n  canvasToBlob,\n  nodeToDataURL,\n  checkCanvasDimensions,\n} from './util'\n\nexport async function toSvg<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<string> {\n  const { width, height } = getImageSize(node, options)\n  const clonedNode = (await cloneNode(node, options, true)) as HTMLElement\n  await embedWebFonts(clonedNode, options)\n  await embedImages(clonedNode, options)\n  applyStyle(clonedNode, options)\n  const datauri = await nodeToDataURL(clonedNode, width, height)\n  return datauri\n}\n\nexport async function toCanvas<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<HTMLCanvasElement> {\n  const { width, height } = getImageSize(node, options)\n  const svg = await toSvg(node, options)\n  const img = await createImage(svg)\n\n  const canvas = document.createElement('canvas')\n  const context = canvas.getContext('2d')!\n  const ratio = options.pixelRatio || getPixelRatio()\n  const canvasWidth = options.canvasWidth || width\n  const canvasHeight = options.canvasHeight || height\n\n  canvas.width = canvasWidth * ratio\n  canvas.height = canvasHeight * ratio\n\n  if (!options.skipAutoScale) {\n    checkCanvasDimensions(canvas)\n  }\n  canvas.style.width = `${canvasWidth}`\n  canvas.style.height = `${canvasHeight}`\n\n  if (options.backgroundColor) {\n    context.fillStyle = options.backgroundColor\n    context.fillRect(0, 0, canvas.width, canvas.height)\n  }\n\n  context.drawImage(img, 0, 0, canvas.width, canvas.height)\n\n  return canvas\n}\n\nexport async function toPixelData<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<Uint8ClampedArray> {\n  const { width, height } = getImageSize(node, options)\n  const canvas = await toCanvas(node, options)\n  const ctx = canvas.getContext('2d')!\n  return ctx.getImageData(0, 0, width, height).data\n}\n\nexport async function toPng<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<string> {\n  const canvas = await toCanvas(node, options)\n  return canvas.toDataURL()\n}\n\nexport async function toJpeg<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<string> {\n  const canvas = await toCanvas(node, options)\n  return canvas.toDataURL('image/jpeg', options.quality || 1)\n}\n\nexport async function toBlob<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<Blob | null> {\n  const canvas = await toCanvas(node, options)\n  const blob = await canvasToBlob(canvas)\n  return blob\n}\n\nexport async function getFontEmbedCSS<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<string> {\n  return getWebFontCSS(node, options)\n}\n","import { clonePseudoElements } from './clone-pseudos';\nimport { createImage, toArray, isInstanceOfElement } from './util';\nimport { getMimeType } from './mimes';\nimport { resourceToDataURL } from './dataurl';\nasync function cloneCanvasElement(canvas) {\n    const dataURL = canvas.toDataURL();\n    if (dataURL === 'data:,') {\n        return canvas.cloneNode(false);\n    }\n    return createImage(dataURL);\n}\nasync function cloneVideoElement(video, options) {\n    if (video.currentSrc) {\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        canvas.width = video.clientWidth;\n        canvas.height = video.clientHeight;\n        ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n        const dataURL = canvas.toDataURL();\n        return createImage(dataURL);\n    }\n    const poster = video.poster;\n    const contentType = getMimeType(poster);\n    const dataURL = await resourceToDataURL(poster, contentType, options);\n    return createImage(dataURL);\n}\nasync function cloneIFrameElement(iframe) {\n    var _a;\n    try {\n        if ((_a = iframe === null || iframe === void 0 ? void 0 : iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.body) {\n            return (await cloneNode(iframe.contentDocument.body, {}, true));\n        }\n    }\n    catch (_b) {\n        // Failed to clone iframe\n    }\n    return iframe.cloneNode(false);\n}\nasync function cloneSingleNode(node, options) {\n    if (isInstanceOfElement(node, HTMLCanvasElement)) {\n        return cloneCanvasElement(node);\n    }\n    if (isInstanceOfElement(node, HTMLVideoElement)) {\n        return cloneVideoElement(node, options);\n    }\n    if (isInstanceOfElement(node, HTMLIFrameElement)) {\n        return cloneIFrameElement(node);\n    }\n    return node.cloneNode(false);\n}\nconst isSlotElement = (node) => node.tagName != null && node.tagName.toUpperCase() === 'SLOT';\nasync function cloneChildren(nativeNode, clonedNode, options) {\n    var _a, _b;\n    let children = [];\n    if (isSlotElement(nativeNode) && nativeNode.assignedNodes) {\n        children = toArray(nativeNode.assignedNodes());\n    }\n    else if (isInstanceOfElement(nativeNode, HTMLIFrameElement) &&\n        ((_a = nativeNode.contentDocument) === null || _a === void 0 ? void 0 : _a.body)) {\n        children = toArray(nativeNode.contentDocument.body.childNodes);\n    }\n    else {\n        children = toArray(((_b = nativeNode.shadowRoot) !== null && _b !== void 0 ? _b : nativeNode).childNodes);\n    }\n    if (children.length === 0 ||\n        isInstanceOfElement(nativeNode, HTMLVideoElement)) {\n        return clonedNode;\n    }\n    await children.reduce((deferred, child) => deferred\n        .then(() => cloneNode(child, options))\n        .then((clonedChild) => {\n        if (clonedChild) {\n            clonedNode.appendChild(clonedChild);\n        }\n    }), Promise.resolve());\n    return clonedNode;\n}\nfunction cloneCSSStyle(nativeNode, clonedNode) {\n    const targetStyle = clonedNode.style;\n    if (!targetStyle) {\n        return;\n    }\n    const sourceStyle = window.getComputedStyle(nativeNode);\n    if (sourceStyle.cssText) {\n        targetStyle.cssText = sourceStyle.cssText;\n        targetStyle.transformOrigin = sourceStyle.transformOrigin;\n    }\n    else {\n        toArray(sourceStyle).forEach((name) => {\n            let value = sourceStyle.getPropertyValue(name);\n            if (name === 'font-size' && value.endsWith('px')) {\n                const reducedFont = Math.floor(parseFloat(value.substring(0, value.length - 2))) - 0.1;\n                value = `${reducedFont}px`;\n            }\n            if (isInstanceOfElement(nativeNode, HTMLIFrameElement) &&\n                name === 'display' &&\n                value === 'inline') {\n                value = 'block';\n            }\n            if (name === 'd' && clonedNode.getAttribute('d')) {\n                value = `path(${clonedNode.getAttribute('d')})`;\n            }\n            targetStyle.setProperty(name, value, sourceStyle.getPropertyPriority(name));\n        });\n    }\n}\nfunction cloneInputValue(nativeNode, clonedNode) {\n    if (isInstanceOfElement(nativeNode, HTMLTextAreaElement)) {\n        clonedNode.innerHTML = nativeNode.value;\n    }\n    if (isInstanceOfElement(nativeNode, HTMLInputElement)) {\n        clonedNode.setAttribute('value', nativeNode.value);\n    }\n}\nfunction cloneSelectValue(nativeNode, clonedNode) {\n    if (isInstanceOfElement(nativeNode, HTMLSelectElement)) {\n        const clonedSelect = clonedNode;\n        const selectedOption = Array.from(clonedSelect.children).find((child) => nativeNode.value === child.getAttribute('value'));\n        if (selectedOption) {\n            selectedOption.setAttribute('selected', '');\n        }\n    }\n}\nfunction decorate(nativeNode, clonedNode) {\n    if (isInstanceOfElement(clonedNode, Element)) {\n        cloneCSSStyle(nativeNode, clonedNode);\n        clonePseudoElements(nativeNode, clonedNode);\n        cloneInputValue(nativeNode, clonedNode);\n        cloneSelectValue(nativeNode, clonedNode);\n    }\n    return clonedNode;\n}\nasync function ensureSVGSymbols(clone, options) {\n    const uses = clone.querySelectorAll ? clone.querySelectorAll('use') : [];\n    if (uses.length === 0) {\n        return clone;\n    }\n    const processedDefs = {};\n    for (let i = 0; i < uses.length; i++) {\n        const use = uses[i];\n        const id = use.getAttribute('xlink:href');\n        if (id) {\n            const exist = clone.querySelector(id);\n            const definition = document.querySelector(id);\n            if (!exist && definition && !processedDefs[id]) {\n                // eslint-disable-next-line no-await-in-loop\n                processedDefs[id] = (await cloneNode(definition, options, true));\n            }\n        }\n    }\n    const nodes = Object.values(processedDefs);\n    if (nodes.length) {\n        const ns = 'http://www.w3.org/1999/xhtml';\n        const svg = document.createElementNS(ns, 'svg');\n        svg.setAttribute('xmlns', ns);\n        svg.style.position = 'absolute';\n        svg.style.width = '0';\n        svg.style.height = '0';\n        svg.style.overflow = 'hidden';\n        svg.style.display = 'none';\n        const defs = document.createElementNS(ns, 'defs');\n        svg.appendChild(defs);\n        for (let i = 0; i < nodes.length; i++) {\n            defs.appendChild(nodes[i]);\n        }\n        clone.appendChild(svg);\n    }\n    return clone;\n}\nexport async function cloneNode(node, options, isRoot) {\n    if (!isRoot && options.filter && !options.filter(node)) {\n        return null;\n    }\n    return Promise.resolve(node)\n        .then((clonedNode) => cloneSingleNode(clonedNode, options))\n        .then((clonedNode) => cloneChildren(node, clonedNode, options))\n        .then((clonedNode) => decorate(node, clonedNode))\n        .then((clonedNode) => ensureSVGSymbols(clonedNode, options));\n}\n//# sourceMappingURL=clone-node.js.map","import type { Options } from './types'\nimport { clonePseudoElements } from './clone-pseudos'\nimport { createImage, toArray, isInstanceOfElement } from './util'\nimport { getMimeType } from './mimes'\nimport { resourceToDataURL } from './dataurl'\n\nasync function cloneCanvasElement(canvas: HTMLCanvasElement) {\n  const dataURL = canvas.toDataURL()\n  if (dataURL === 'data:,') {\n    return canvas.cloneNode(false) as HTMLCanvasElement\n  }\n  return createImage(dataURL)\n}\n\nasync function cloneVideoElement(video: HTMLVideoElement, options: Options) {\n  if (video.currentSrc) {\n    const canvas = document.createElement('canvas')\n    const ctx = canvas.getContext('2d')\n    canvas.width = video.clientWidth\n    canvas.height = video.clientHeight\n    ctx?.drawImage(video, 0, 0, canvas.width, canvas.height)\n    const dataURL = canvas.toDataURL()\n    return createImage(dataURL)\n  }\n\n  const poster = video.poster\n  const contentType = getMimeType(poster)\n  const dataURL = await resourceToDataURL(poster, contentType, options)\n  return createImage(dataURL)\n}\n\nasync function cloneIFrameElement(iframe: HTMLIFrameElement) {\n  try {\n    if (iframe?.contentDocument?.body) {\n      return (await cloneNode(\n        iframe.contentDocument.body,\n        {},\n        true,\n      )) as HTMLBodyElement\n    }\n  } catch {\n    // Failed to clone iframe\n  }\n\n  return iframe.cloneNode(false) as HTMLIFrameElement\n}\n\nasync function cloneSingleNode<T extends HTMLElement>(\n  node: T,\n  options: Options,\n): Promise<HTMLElement> {\n  if (isInstanceOfElement(node, HTMLCanvasElement)) {\n    return cloneCanvasElement(node)\n  }\n\n  if (isInstanceOfElement(node, HTMLVideoElement)) {\n    return cloneVideoElement(node, options)\n  }\n\n  if (isInstanceOfElement(node, HTMLIFrameElement)) {\n    return cloneIFrameElement(node)\n  }\n\n  return node.cloneNode(false) as T\n}\n\nconst isSlotElement = (node: HTMLElement): node is HTMLSlotElement =>\n  node.tagName != null && node.tagName.toUpperCase() === 'SLOT'\n\nasync function cloneChildren<T extends HTMLElement>(\n  nativeNode: T,\n  clonedNode: T,\n  options: Options,\n): Promise<T> {\n  let children: T[] = []\n\n  if (isSlotElement(nativeNode) && nativeNode.assignedNodes) {\n    children = toArray<T>(nativeNode.assignedNodes())\n  } else if (\n    isInstanceOfElement(nativeNode, HTMLIFrameElement) &&\n    nativeNode.contentDocument?.body\n  ) {\n    children = toArray<T>(nativeNode.contentDocument.body.childNodes)\n  } else {\n    children = toArray<T>((nativeNode.shadowRoot ?? nativeNode).childNodes)\n  }\n\n  if (\n    children.length === 0 ||\n    isInstanceOfElement(nativeNode, HTMLVideoElement)\n  ) {\n    return clonedNode\n  }\n\n  await children.reduce(\n    (deferred, child) =>\n      deferred\n        .then(() => cloneNode(child, options))\n        .then((clonedChild: HTMLElement | null) => {\n          if (clonedChild) {\n            clonedNode.appendChild(clonedChild)\n          }\n        }),\n    Promise.resolve(),\n  )\n\n  return clonedNode\n}\n\nfunction cloneCSSStyle<T extends HTMLElement>(nativeNode: T, clonedNode: T) {\n  const targetStyle = clonedNode.style\n  if (!targetStyle) {\n    return\n  }\n\n  const sourceStyle = window.getComputedStyle(nativeNode)\n  if (sourceStyle.cssText) {\n    targetStyle.cssText = sourceStyle.cssText\n    targetStyle.transformOrigin = sourceStyle.transformOrigin\n  } else {\n    toArray<string>(sourceStyle).forEach((name) => {\n      let value = sourceStyle.getPropertyValue(name)\n      if (name === 'font-size' && value.endsWith('px')) {\n        const reducedFont =\n          Math.floor(parseFloat(value.substring(0, value.length - 2))) - 0.1\n        value = `${reducedFont}px`\n      }\n\n      if (\n        isInstanceOfElement(nativeNode, HTMLIFrameElement) &&\n        name === 'display' &&\n        value === 'inline'\n      ) {\n        value = 'block'\n      }\n      \n      if (name === 'd' && clonedNode.getAttribute('d')) {\n        value = `path(${clonedNode.getAttribute('d')})`\n      }\n      \n      targetStyle.setProperty(\n        name,\n        value,\n        sourceStyle.getPropertyPriority(name),\n      )\n    })\n  }\n}\n\nfunction cloneInputValue<T extends HTMLElement>(nativeNode: T, clonedNode: T) {\n  if (isInstanceOfElement(nativeNode, HTMLTextAreaElement)) {\n    clonedNode.innerHTML = nativeNode.value\n  }\n\n  if (isInstanceOfElement(nativeNode, HTMLInputElement)) {\n    clonedNode.setAttribute('value', nativeNode.value)\n  }\n}\n\nfunction cloneSelectValue<T extends HTMLElement>(nativeNode: T, clonedNode: T) {\n  if (isInstanceOfElement(nativeNode, HTMLSelectElement)) {\n    const clonedSelect = clonedNode as any as HTMLSelectElement\n    const selectedOption = Array.from(clonedSelect.children).find(\n      (child) => nativeNode.value === child.getAttribute('value'),\n    )\n\n    if (selectedOption) {\n      selectedOption.setAttribute('selected', '')\n    }\n  }\n}\n\nfunction decorate<T extends HTMLElement>(nativeNode: T, clonedNode: T): T {\n  if (isInstanceOfElement(clonedNode, Element)) {\n    cloneCSSStyle(nativeNode, clonedNode)\n    clonePseudoElements(nativeNode, clonedNode)\n    cloneInputValue(nativeNode, clonedNode)\n    cloneSelectValue(nativeNode, clonedNode)\n  }\n\n  return clonedNode\n}\n\nasync function ensureSVGSymbols<T extends HTMLElement>(\n  clone: T,\n  options: Options,\n) {\n  const uses = clone.querySelectorAll ? clone.querySelectorAll('use') : []\n  if (uses.length === 0) {\n    return clone\n  }\n\n  const processedDefs: { [key: string]: HTMLElement } = {}\n  for (let i = 0; i < uses.length; i++) {\n    const use = uses[i]\n    const id = use.getAttribute('xlink:href')\n    if (id) {\n      const exist = clone.querySelector(id)\n      const definition = document.querySelector(id) as HTMLElement\n      if (!exist && definition && !processedDefs[id]) {\n        // eslint-disable-next-line no-await-in-loop\n        processedDefs[id] = (await cloneNode(definition, options, true))!\n      }\n    }\n  }\n\n  const nodes = Object.values(processedDefs)\n  if (nodes.length) {\n    const ns = 'http://www.w3.org/1999/xhtml'\n    const svg = document.createElementNS(ns, 'svg')\n    svg.setAttribute('xmlns', ns)\n    svg.style.position = 'absolute'\n    svg.style.width = '0'\n    svg.style.height = '0'\n    svg.style.overflow = 'hidden'\n    svg.style.display = 'none'\n\n    const defs = document.createElementNS(ns, 'defs')\n    svg.appendChild(defs)\n\n    for (let i = 0; i < nodes.length; i++) {\n      defs.appendChild(nodes[i])\n    }\n\n    clone.appendChild(svg)\n  }\n\n  return clone\n}\n\nexport async function cloneNode<T extends HTMLElement>(\n  node: T,\n  options: Options,\n  isRoot?: boolean,\n): Promise<T | null> {\n  if (!isRoot && options.filter && !options.filter(node)) {\n    return null\n  }\n\n  return Promise.resolve(node)\n    .then((clonedNode) => cloneSingleNode(clonedNode, options) as Promise<T>)\n    .then((clonedNode) => cloneChildren(node, clonedNode, options))\n    .then((clonedNode) => decorate(node, clonedNode))\n    .then((clonedNode) => ensureSVGSymbols(clonedNode, options))\n}\n","import { uuid, toArray } from './util';\nfunction formatCSSText(style) {\n    const content = style.getPropertyValue('content');\n    return `${style.cssText} content: '${content.replace(/'|\"/g, '')}';`;\n}\nfunction formatCSSProperties(style) {\n    return toArray(style)\n        .map((name) => {\n        const value = style.getPropertyValue(name);\n        const priority = style.getPropertyPriority(name);\n        return `${name}: ${value}${priority ? ' !important' : ''};`;\n    })\n        .join(' ');\n}\nfunction getPseudoElementStyle(className, pseudo, style) {\n    const selector = `.${className}:${pseudo}`;\n    const cssText = style.cssText\n        ? formatCSSText(style)\n        : formatCSSProperties(style);\n    return document.createTextNode(`${selector}{${cssText}}`);\n}\nfunction clonePseudoElement(nativeNode, clonedNode, pseudo) {\n    const style = window.getComputedStyle(nativeNode, pseudo);\n    const content = style.getPropertyValue('content');\n    if (content === '' || content === 'none') {\n        return;\n    }\n    const className = uuid();\n    try {\n        clonedNode.className = `${clonedNode.className} ${className}`;\n    }\n    catch (err) {\n        return;\n    }\n    const styleElement = document.createElement('style');\n    styleElement.appendChild(getPseudoElementStyle(className, pseudo, style));\n    clonedNode.appendChild(styleElement);\n}\nexport function clonePseudoElements(nativeNode, clonedNode) {\n    clonePseudoElement(nativeNode, clonedNode, ':before');\n    clonePseudoElement(nativeNode, clonedNode, ':after');\n}\n//# sourceMappingURL=clone-pseudos.js.map","import { uuid, toArray } from './util'\n\ntype Pseudo = ':before' | ':after'\n\nfunction formatCSSText(style: CSSStyleDeclaration) {\n  const content = style.getPropertyValue('content')\n  return `${style.cssText} content: '${content.replace(/'|\"/g, '')}';`\n}\n\nfunction formatCSSProperties(style: CSSStyleDeclaration) {\n  return toArray<string>(style)\n    .map((name) => {\n      const value = style.getPropertyValue(name)\n      const priority = style.getPropertyPriority(name)\n\n      return `${name}: ${value}${priority ? ' !important' : ''};`\n    })\n    .join(' ')\n}\n\nfunction getPseudoElementStyle(\n  className: string,\n  pseudo: Pseudo,\n  style: CSSStyleDeclaration,\n): Text {\n  const selector = `.${className}:${pseudo}`\n  const cssText = style.cssText\n    ? formatCSSText(style)\n    : formatCSSProperties(style)\n\n  return document.createTextNode(`${selector}{${cssText}}`)\n}\n\nfunction clonePseudoElement<T extends HTMLElement>(\n  nativeNode: T,\n  clonedNode: T,\n  pseudo: Pseudo,\n) {\n  const style = window.getComputedStyle(nativeNode, pseudo)\n  const content = style.getPropertyValue('content')\n  if (content === '' || content === 'none') {\n    return\n  }\n\n  const className = uuid()\n  try {\n    clonedNode.className = `${clonedNode.className} ${className}`\n  } catch (err) {\n    return\n  }\n\n  const styleElement = document.createElement('style')\n  styleElement.appendChild(getPseudoElementStyle(className, pseudo, style))\n  clonedNode.appendChild(styleElement)\n}\n\nexport function clonePseudoElements<T extends HTMLElement>(\n  nativeNode: T,\n  clonedNode: T,\n) {\n  clonePseudoElement(nativeNode, clonedNode, ':before')\n  clonePseudoElement(nativeNode, clonedNode, ':after')\n}\n","export function resolveUrl(url, baseUrl) {\n    // url is absolute already\n    if (url.match(/^[a-z]+:\\/\\//i)) {\n        return url;\n    }\n    // url is absolute already, without protocol\n    if (url.match(/^\\/\\//)) {\n        return window.location.protocol + url;\n    }\n    // dataURI, mailto:, tel:, etc.\n    if (url.match(/^[a-z]+:/i)) {\n        return url;\n    }\n    const doc = document.implementation.createHTMLDocument();\n    const base = doc.createElement('base');\n    const a = doc.createElement('a');\n    doc.head.appendChild(base);\n    doc.body.appendChild(a);\n    if (baseUrl) {\n        base.href = baseUrl;\n    }\n    a.href = url;\n    return a.href;\n}\nexport const uuid = (() => {\n    // generate uuid for className of pseudo elements.\n    // We should not use GUIDs, otherwise pseudo elements sometimes cannot be captured.\n    let counter = 0;\n    // ref: http://stackoverflow.com/a/6248722/2519373\n    const random = () => \n    // eslint-disable-next-line no-bitwise\n    `0000${((Math.random() * 36 ** 4) << 0).toString(36)}`.slice(-4);\n    return () => {\n        counter += 1;\n        return `u${random()}${counter}`;\n    };\n})();\nexport function delay(ms) {\n    return (args) => new Promise((resolve) => {\n        setTimeout(() => resolve(args), ms);\n    });\n}\nexport function toArray(arrayLike) {\n    const arr = [];\n    for (let i = 0, l = arrayLike.length; i < l; i++) {\n        arr.push(arrayLike[i]);\n    }\n    return arr;\n}\nfunction px(node, styleProperty) {\n    const win = node.ownerDocument.defaultView || window;\n    const val = win.getComputedStyle(node).getPropertyValue(styleProperty);\n    return val ? parseFloat(val.replace('px', '')) : 0;\n}\nfunction getNodeWidth(node) {\n    const leftBorder = px(node, 'border-left-width');\n    const rightBorder = px(node, 'border-right-width');\n    return node.clientWidth + leftBorder + rightBorder;\n}\nfunction getNodeHeight(node) {\n    const topBorder = px(node, 'border-top-width');\n    const bottomBorder = px(node, 'border-bottom-width');\n    return node.clientHeight + topBorder + bottomBorder;\n}\nexport function getImageSize(targetNode, options = {}) {\n    const width = options.width || getNodeWidth(targetNode);\n    const height = options.height || getNodeHeight(targetNode);\n    return { width, height };\n}\nexport function getPixelRatio() {\n    let ratio;\n    let FINAL_PROCESS;\n    try {\n        FINAL_PROCESS = process;\n    }\n    catch (e) {\n        // pass\n    }\n    const val = FINAL_PROCESS && FINAL_PROCESS.env\n        ? FINAL_PROCESS.env.devicePixelRatio\n        : null;\n    if (val) {\n        ratio = parseInt(val, 10);\n        if (Number.isNaN(ratio)) {\n            ratio = 1;\n        }\n    }\n    return ratio || window.devicePixelRatio || 1;\n}\n// @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas#maximum_canvas_size\nconst canvasDimensionLimit = 16384;\nexport function checkCanvasDimensions(canvas) {\n    if (canvas.width > canvasDimensionLimit ||\n        canvas.height > canvasDimensionLimit) {\n        if (canvas.width > canvasDimensionLimit &&\n            canvas.height > canvasDimensionLimit) {\n            if (canvas.width > canvas.height) {\n                canvas.height *= canvasDimensionLimit / canvas.width;\n                canvas.width = canvasDimensionLimit;\n            }\n            else {\n                canvas.width *= canvasDimensionLimit / canvas.height;\n                canvas.height = canvasDimensionLimit;\n            }\n        }\n        else if (canvas.width > canvasDimensionLimit) {\n            canvas.height *= canvasDimensionLimit / canvas.width;\n            canvas.width = canvasDimensionLimit;\n        }\n        else {\n            canvas.width *= canvasDimensionLimit / canvas.height;\n            canvas.height = canvasDimensionLimit;\n        }\n    }\n}\nexport function canvasToBlob(canvas, options = {}) {\n    if (canvas.toBlob) {\n        return new Promise((resolve) => {\n            canvas.toBlob(resolve, options.type ? options.type : 'image/png', options.quality ? options.quality : 1);\n        });\n    }\n    return new Promise((resolve) => {\n        const binaryString = window.atob(canvas\n            .toDataURL(options.type ? options.type : undefined, options.quality ? options.quality : undefined)\n            .split(',')[1]);\n        const len = binaryString.length;\n        const binaryArray = new Uint8Array(len);\n        for (let i = 0; i < len; i += 1) {\n            binaryArray[i] = binaryString.charCodeAt(i);\n        }\n        resolve(new Blob([binaryArray], {\n            type: options.type ? options.type : 'image/png',\n        }));\n    });\n}\nexport function createImage(url) {\n    return new Promise((resolve, reject) => {\n        const img = new Image();\n        img.decode = () => resolve(img);\n        img.onload = () => resolve(img);\n        img.onerror = reject;\n        img.crossOrigin = 'anonymous';\n        img.decoding = 'async';\n        img.src = url;\n    });\n}\nexport async function svgToDataURL(svg) {\n    return Promise.resolve()\n        .then(() => new XMLSerializer().serializeToString(svg))\n        .then(encodeURIComponent)\n        .then((html) => `data:image/svg+xml;charset=utf-8,${html}`);\n}\nexport async function nodeToDataURL(node, width, height) {\n    const xmlns = 'http://www.w3.org/2000/svg';\n    const svg = document.createElementNS(xmlns, 'svg');\n    const foreignObject = document.createElementNS(xmlns, 'foreignObject');\n    svg.setAttribute('width', `${width}`);\n    svg.setAttribute('height', `${height}`);\n    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);\n    foreignObject.setAttribute('width', '100%');\n    foreignObject.setAttribute('height', '100%');\n    foreignObject.setAttribute('x', '0');\n    foreignObject.setAttribute('y', '0');\n    foreignObject.setAttribute('externalResourcesRequired', 'true');\n    svg.appendChild(foreignObject);\n    foreignObject.appendChild(node);\n    return svgToDataURL(svg);\n}\nexport const isInstanceOfElement = (node, instance) => {\n    if (node instanceof instance)\n        return true;\n    const nodePrototype = Object.getPrototypeOf(node);\n    if (nodePrototype === null)\n        return false;\n    return (nodePrototype.constructor.name === instance.name ||\n        isInstanceOfElement(nodePrototype, instance));\n};\n//# sourceMappingURL=util.js.map","import type { Options } from './types'\n\nexport function resolveUrl(url: string, baseUrl: string | null): string {\n  // url is absolute already\n  if (url.match(/^[a-z]+:\\/\\//i)) {\n    return url\n  }\n\n  // url is absolute already, without protocol\n  if (url.match(/^\\/\\//)) {\n    return window.location.protocol + url\n  }\n\n  // dataURI, mailto:, tel:, etc.\n  if (url.match(/^[a-z]+:/i)) {\n    return url\n  }\n\n  const doc = document.implementation.createHTMLDocument()\n  const base = doc.createElement('base')\n  const a = doc.createElement('a')\n\n  doc.head.appendChild(base)\n  doc.body.appendChild(a)\n\n  if (baseUrl) {\n    base.href = baseUrl\n  }\n\n  a.href = url\n\n  return a.href\n}\n\nexport const uuid = (() => {\n  // generate uuid for className of pseudo elements.\n  // We should not use GUIDs, otherwise pseudo elements sometimes cannot be captured.\n  let counter = 0\n\n  // ref: http://stackoverflow.com/a/6248722/2519373\n  const random = () =>\n    // eslint-disable-next-line no-bitwise\n    `0000${((Math.random() * 36 ** 4) << 0).toString(36)}`.slice(-4)\n\n  return () => {\n    counter += 1\n    return `u${random()}${counter}`\n  }\n})()\n\nexport function delay<T>(ms: number) {\n  return (args: T) =>\n    new Promise<T>((resolve) => {\n      setTimeout(() => resolve(args), ms)\n    })\n}\n\nexport function toArray<T>(arrayLike: any): T[] {\n  const arr: T[] = []\n\n  for (let i = 0, l = arrayLike.length; i < l; i++) {\n    arr.push(arrayLike[i])\n  }\n\n  return arr\n}\n\nfunction px(node: HTMLElement, styleProperty: string) {\n  const win = node.ownerDocument.defaultView || window\n  const val = win.getComputedStyle(node).getPropertyValue(styleProperty)\n  return val ? parseFloat(val.replace('px', '')) : 0\n}\n\nfunction getNodeWidth(node: HTMLElement) {\n  const leftBorder = px(node, 'border-left-width')\n  const rightBorder = px(node, 'border-right-width')\n  return node.clientWidth + leftBorder + rightBorder\n}\n\nfunction getNodeHeight(node: HTMLElement) {\n  const topBorder = px(node, 'border-top-width')\n  const bottomBorder = px(node, 'border-bottom-width')\n  return node.clientHeight + topBorder + bottomBorder\n}\n\nexport function getImageSize(targetNode: HTMLElement, options: Options = {}) {\n  const width = options.width || getNodeWidth(targetNode)\n  const height = options.height || getNodeHeight(targetNode)\n\n  return { width, height }\n}\n\nexport function getPixelRatio() {\n  let ratio\n\n  let FINAL_PROCESS\n  try {\n    FINAL_PROCESS = process\n  } catch (e) {\n    // pass\n  }\n\n  const val =\n    FINAL_PROCESS && FINAL_PROCESS.env\n      ? FINAL_PROCESS.env.devicePixelRatio\n      : null\n  if (val) {\n    ratio = parseInt(val, 10)\n    if (Number.isNaN(ratio)) {\n      ratio = 1\n    }\n  }\n  return ratio || window.devicePixelRatio || 1\n}\n\n// @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas#maximum_canvas_size\nconst canvasDimensionLimit = 16384\n\nexport function checkCanvasDimensions(canvas: HTMLCanvasElement) {\n  if (\n    canvas.width > canvasDimensionLimit ||\n    canvas.height > canvasDimensionLimit\n  ) {\n    if (\n      canvas.width > canvasDimensionLimit &&\n      canvas.height > canvasDimensionLimit\n    ) {\n      if (canvas.width > canvas.height) {\n        canvas.height *= canvasDimensionLimit / canvas.width\n        canvas.width = canvasDimensionLimit\n      } else {\n        canvas.width *= canvasDimensionLimit / canvas.height\n        canvas.height = canvasDimensionLimit\n      }\n    } else if (canvas.width > canvasDimensionLimit) {\n      canvas.height *= canvasDimensionLimit / canvas.width\n      canvas.width = canvasDimensionLimit\n    } else {\n      canvas.width *= canvasDimensionLimit / canvas.height\n      canvas.height = canvasDimensionLimit\n    }\n  }\n}\n\nexport function canvasToBlob(\n  canvas: HTMLCanvasElement,\n  options: Options = {},\n): Promise<Blob | null> {\n  if (canvas.toBlob) {\n    return new Promise((resolve) => {\n      canvas.toBlob(\n        resolve,\n        options.type ? options.type : 'image/png',\n        options.quality ? options.quality : 1,\n      )\n    })\n  }\n\n  return new Promise((resolve) => {\n    const binaryString = window.atob(\n      canvas\n        .toDataURL(\n          options.type ? options.type : undefined,\n          options.quality ? options.quality : undefined,\n        )\n        .split(',')[1],\n    )\n    const len = binaryString.length\n    const binaryArray = new Uint8Array(len)\n\n    for (let i = 0; i < len; i += 1) {\n      binaryArray[i] = binaryString.charCodeAt(i)\n    }\n\n    resolve(\n      new Blob([binaryArray], {\n        type: options.type ? options.type : 'image/png',\n      }),\n    )\n  })\n}\n\nexport function createImage(url: string): Promise<HTMLImageElement> {\n  return new Promise((resolve, reject) => {\n    const img = new Image()\n    img.decode = () => resolve(img) as any\n    img.onload = () => resolve(img)\n    img.onerror = reject\n    img.crossOrigin = 'anonymous'\n    img.decoding = 'async'\n    img.src = url\n  })\n}\n\nexport async function svgToDataURL(svg: SVGElement): Promise<string> {\n  return Promise.resolve()\n    .then(() => new XMLSerializer().serializeToString(svg))\n    .then(encodeURIComponent)\n    .then((html) => `data:image/svg+xml;charset=utf-8,${html}`)\n}\n\nexport async function nodeToDataURL(\n  node: HTMLElement,\n  width: number,\n  height: number,\n): Promise<string> {\n  const xmlns = 'http://www.w3.org/2000/svg'\n  const svg = document.createElementNS(xmlns, 'svg')\n  const foreignObject = document.createElementNS(xmlns, 'foreignObject')\n\n  svg.setAttribute('width', `${width}`)\n  svg.setAttribute('height', `${height}`)\n  svg.setAttribute('viewBox', `0 0 ${width} ${height}`)\n\n  foreignObject.setAttribute('width', '100%')\n  foreignObject.setAttribute('height', '100%')\n  foreignObject.setAttribute('x', '0')\n  foreignObject.setAttribute('y', '0')\n  foreignObject.setAttribute('externalResourcesRequired', 'true')\n\n  svg.appendChild(foreignObject)\n  foreignObject.appendChild(node)\n  return svgToDataURL(svg)\n}\n\nexport const isInstanceOfElement = <\n  T extends typeof Element | typeof HTMLElement | typeof SVGImageElement,\n>(\n  node: Element | HTMLElement | SVGImageElement,\n  instance: T,\n): node is T['prototype'] => {\n  if (node instanceof instance) return true\n\n  const nodePrototype = Object.getPrototypeOf(node)\n\n  if (nodePrototype === null) return false\n\n  return (\n    nodePrototype.constructor.name === instance.name ||\n    isInstanceOfElement(nodePrototype, instance)\n  )\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","const WOFF = 'application/font-woff';\nconst JPEG = 'image/jpeg';\nconst mimes = {\n    woff: WOFF,\n    woff2: WOFF,\n    ttf: 'application/font-truetype',\n    eot: 'application/vnd.ms-fontobject',\n    png: 'image/png',\n    jpg: JPEG,\n    jpeg: JPEG,\n    gif: 'image/gif',\n    tiff: 'image/tiff',\n    svg: 'image/svg+xml',\n    webp: 'image/webp',\n};\nfunction getExtension(url) {\n    const match = /\\.([^./]*?)$/g.exec(url);\n    return match ? match[1] : '';\n}\nexport function getMimeType(url) {\n    const extension = getExtension(url).toLowerCase();\n    return mimes[extension] || '';\n}\n//# sourceMappingURL=mimes.js.map","const WOFF = 'application/font-woff'\nconst JPEG = 'image/jpeg'\nconst mimes: { [key: string]: string } = {\n  woff: WOFF,\n  woff2: WOFF,\n  ttf: 'application/font-truetype',\n  eot: 'application/vnd.ms-fontobject',\n  png: 'image/png',\n  jpg: JPEG,\n  jpeg: JPEG,\n  gif: 'image/gif',\n  tiff: 'image/tiff',\n  svg: 'image/svg+xml',\n  webp: 'image/webp',\n}\n\nfunction getExtension(url: string): string {\n  const match = /\\.([^./]*?)$/g.exec(url)\n  return match ? match[1] : ''\n}\n\nexport function getMimeType(url: string): string {\n  const extension = getExtension(url).toLowerCase()\n  return mimes[extension] || ''\n}\n","function getContentFromDataUrl(dataURL) {\n    return dataURL.split(/,/)[1];\n}\nexport function isDataUrl(url) {\n    return url.search(/^(data:)/) !== -1;\n}\nexport function makeDataUrl(content, mimeType) {\n    return `data:${mimeType};base64,${content}`;\n}\nexport async function fetchAsDataURL(url, init, process) {\n    const res = await fetch(url, init);\n    if (res.status === 404) {\n        throw new Error(`Resource \"${res.url}\" not found`);\n    }\n    const blob = await res.blob();\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onerror = reject;\n        reader.onloadend = () => {\n            try {\n                resolve(process({ res, result: reader.result }));\n            }\n            catch (error) {\n                reject(error);\n            }\n        };\n        reader.readAsDataURL(blob);\n    });\n}\nconst cache = {};\nfunction getCacheKey(url, contentType, includeQueryParams) {\n    let key = url.replace(/\\?.*/, '');\n    if (includeQueryParams) {\n        key = url;\n    }\n    // font resource\n    if (/ttf|otf|eot|woff2?/i.test(key)) {\n        key = key.replace(/.*\\//, '');\n    }\n    return contentType ? `[${contentType}]${key}` : key;\n}\nexport async function resourceToDataURL(resourceUrl, contentType, options) {\n    const cacheKey = getCacheKey(resourceUrl, contentType, options.includeQueryParams);\n    if (cache[cacheKey] != null) {\n        return cache[cacheKey];\n    }\n    // ref: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache\n    if (options.cacheBust) {\n        // eslint-disable-next-line no-param-reassign\n        resourceUrl += (/\\?/.test(resourceUrl) ? '&' : '?') + new Date().getTime();\n    }\n    let dataURL;\n    try {\n        const content = await fetchAsDataURL(resourceUrl, options.fetchRequestInit, ({ res, result }) => {\n            if (!contentType) {\n                // eslint-disable-next-line no-param-reassign\n                contentType = res.headers.get('Content-Type') || '';\n            }\n            return getContentFromDataUrl(result);\n        });\n        dataURL = makeDataUrl(content, contentType);\n    }\n    catch (error) {\n        dataURL = options.imagePlaceholder || '';\n        let msg = `Failed to fetch resource: ${resourceUrl}`;\n        if (error) {\n            msg = typeof error === 'string' ? error : error.message;\n        }\n        if (msg) {\n            console.warn(msg);\n        }\n    }\n    cache[cacheKey] = dataURL;\n    return dataURL;\n}\n//# sourceMappingURL=dataurl.js.map","import { Options } from './types'\n\nfunction getContentFromDataUrl(dataURL: string) {\n  return dataURL.split(/,/)[1]\n}\n\nexport function isDataUrl(url: string) {\n  return url.search(/^(data:)/) !== -1\n}\n\nexport function makeDataUrl(content: string, mimeType: string) {\n  return `data:${mimeType};base64,${content}`\n}\n\nexport async function fetchAsDataURL<T>(\n  url: string,\n  init: RequestInit | undefined,\n  process: (data: { result: string; res: Response }) => T,\n): Promise<T> {\n  const res = await fetch(url, init)\n  if (res.status === 404) {\n    throw new Error(`Resource \"${res.url}\" not found`)\n  }\n  const blob = await res.blob()\n  return new Promise<T>((resolve, reject) => {\n    const reader = new FileReader()\n    reader.onerror = reject\n    reader.onloadend = () => {\n      try {\n        resolve(process({ res, result: reader.result as string }))\n      } catch (error) {\n        reject(error)\n      }\n    }\n\n    reader.readAsDataURL(blob)\n  })\n}\n\nconst cache: { [url: string]: string } = {}\n\nfunction getCacheKey(\n  url: string,\n  contentType: string | undefined,\n  includeQueryParams: boolean | undefined,\n) {\n  let key = url.replace(/\\?.*/, '')\n\n  if (includeQueryParams) {\n    key = url\n  }\n\n  // font resource\n  if (/ttf|otf|eot|woff2?/i.test(key)) {\n    key = key.replace(/.*\\//, '')\n  }\n\n  return contentType ? `[${contentType}]${key}` : key\n}\n\nexport async function resourceToDataURL(\n  resourceUrl: string,\n  contentType: string | undefined,\n  options: Options,\n) {\n  const cacheKey = getCacheKey(\n    resourceUrl,\n    contentType,\n    options.includeQueryParams,\n  )\n\n  if (cache[cacheKey] != null) {\n    return cache[cacheKey]\n  }\n\n  // ref: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache\n  if (options.cacheBust) {\n    // eslint-disable-next-line no-param-reassign\n    resourceUrl += (/\\?/.test(resourceUrl) ? '&' : '?') + new Date().getTime()\n  }\n\n  let dataURL: string\n  try {\n    const content = await fetchAsDataURL(\n      resourceUrl,\n      options.fetchRequestInit,\n      ({ res, result }) => {\n        if (!contentType) {\n          // eslint-disable-next-line no-param-reassign\n          contentType = res.headers.get('Content-Type') || ''\n        }\n        return getContentFromDataUrl(result)\n      },\n    )\n    dataURL = makeDataUrl(content, contentType!)\n  } catch (error) {\n    dataURL = options.imagePlaceholder || ''\n\n    let msg = `Failed to fetch resource: ${resourceUrl}`\n    if (error) {\n      msg = typeof error === 'string' ? error : error.message\n    }\n\n    if (msg) {\n      console.warn(msg)\n    }\n  }\n\n  cache[cacheKey] = dataURL\n  return dataURL\n}\n","import { embedResources } from './embed-resources';\nimport { toArray, isInstanceOfElement } from './util';\nimport { isDataUrl, resourceToDataURL } from './dataurl';\nimport { getMimeType } from './mimes';\nasync function embedProp(propName, node, options) {\n    var _a;\n    const propValue = (_a = node.style) === null || _a === void 0 ? void 0 : _a.getPropertyValue(propName);\n    if (propValue) {\n        const cssString = await embedResources(propValue, null, options);\n        node.style.setProperty(propName, cssString, node.style.getPropertyPriority(propName));\n        return true;\n    }\n    return false;\n}\nasync function embedBackground(clonedNode, options) {\n    if (!(await embedProp('background', clonedNode, options))) {\n        await embedProp('background-image', clonedNode, options);\n    }\n    if (!(await embedProp('mask', clonedNode, options))) {\n        await embedProp('mask-image', clonedNode, options);\n    }\n}\nasync function embedImageNode(clonedNode, options) {\n    const isImageElement = isInstanceOfElement(clonedNode, HTMLImageElement);\n    if (!(isImageElement && !isDataUrl(clonedNode.src)) &&\n        !(isInstanceOfElement(clonedNode, SVGImageElement) &&\n            !isDataUrl(clonedNode.href.baseVal))) {\n        return;\n    }\n    const url = isImageElement ? clonedNode.src : clonedNode.href.baseVal;\n    const dataURL = await resourceToDataURL(url, getMimeType(url), options);\n    await new Promise((resolve, reject) => {\n        clonedNode.onload = resolve;\n        clonedNode.onerror = reject;\n        const image = clonedNode;\n        if (image.decode) {\n            image.decode = resolve;\n        }\n        if (image.loading === 'lazy') {\n            image.loading = 'eager';\n        }\n        if (isImageElement) {\n            clonedNode.srcset = '';\n            clonedNode.src = dataURL;\n        }\n        else {\n            clonedNode.href.baseVal = dataURL;\n        }\n    });\n}\nasync function embedChildren(clonedNode, options) {\n    const children = toArray(clonedNode.childNodes);\n    const deferreds = children.map((child) => embedImages(child, options));\n    await Promise.all(deferreds).then(() => clonedNode);\n}\nexport async function embedImages(clonedNode, options) {\n    if (isInstanceOfElement(clonedNode, Element)) {\n        await embedBackground(clonedNode, options);\n        await embedImageNode(clonedNode, options);\n        await embedChildren(clonedNode, options);\n    }\n}\n//# sourceMappingURL=embed-images.js.map","import { Options } from './types'\nimport { embedResources } from './embed-resources'\nimport { toArray, isInstanceOfElement } from './util'\nimport { isDataUrl, resourceToDataURL } from './dataurl'\nimport { getMimeType } from './mimes'\n\nasync function embedProp(\n  propName: string,\n  node: HTMLElement,\n  options: Options,\n) {\n  const propValue = node.style?.getPropertyValue(propName)\n  if (propValue) {\n    const cssString = await embedResources(propValue, null, options)\n    node.style.setProperty(\n      propName,\n      cssString,\n      node.style.getPropertyPriority(propName),\n    )\n    return true\n  }\n  return false\n}\n\nasync function embedBackground<T extends HTMLElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  if (!(await embedProp('background', clonedNode, options))) {\n    await embedProp('background-image', clonedNode, options)\n  }\n  if (!(await embedProp('mask', clonedNode, options))) {\n    await embedProp('mask-image', clonedNode, options)\n  }\n}\n\nasync function embedImageNode<T extends HTMLElement | SVGImageElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  const isImageElement = isInstanceOfElement(clonedNode, HTMLImageElement)\n\n  if (\n    !(isImageElement && !isDataUrl(clonedNode.src)) &&\n    !(\n      isInstanceOfElement(clonedNode, SVGImageElement) &&\n      !isDataUrl(clonedNode.href.baseVal)\n    )\n  ) {\n    return\n  }\n\n  const url = isImageElement ? clonedNode.src : clonedNode.href.baseVal\n\n  const dataURL = await resourceToDataURL(url, getMimeType(url), options)\n  await new Promise((resolve, reject) => {\n    clonedNode.onload = resolve\n    clonedNode.onerror = reject\n\n    const image = clonedNode as HTMLImageElement\n    if (image.decode) {\n      image.decode = resolve as any\n    }\n\n    if (image.loading === 'lazy') {\n      image.loading = 'eager'\n    }\n\n    if (isImageElement) {\n      clonedNode.srcset = ''\n      clonedNode.src = dataURL\n    } else {\n      clonedNode.href.baseVal = dataURL\n    }\n  })\n}\n\nasync function embedChildren<T extends HTMLElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  const children = toArray<HTMLElement>(clonedNode.childNodes)\n  const deferreds = children.map((child) => embedImages(child, options))\n  await Promise.all(deferreds).then(() => clonedNode)\n}\n\nexport async function embedImages<T extends HTMLElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  if (isInstanceOfElement(clonedNode, Element)) {\n    await embedBackground(clonedNode, options)\n    await embedImageNode(clonedNode, options)\n    await embedChildren(clonedNode, options)\n  }\n}\n","import { resolveUrl } from './util';\nimport { getMimeType } from './mimes';\nimport { isDataUrl, makeDataUrl, resourceToDataURL } from './dataurl';\nconst URL_REGEX = /url\\((['\"]?)([^'\"]+?)\\1\\)/g;\nconst URL_WITH_FORMAT_REGEX = /url\\([^)]+\\)\\s*format\\(([\"']?)([^\"']+)\\1\\)/g;\nconst FONT_SRC_REGEX = /src:\\s*(?:url\\([^)]+\\)\\s*format\\([^)]+\\)[,;]\\s*)+/g;\nfunction toRegex(url) {\n    // eslint-disable-next-line no-useless-escape\n    const escaped = url.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n    return new RegExp(`(url\\\\(['\"]?)(${escaped})(['\"]?\\\\))`, 'g');\n}\nexport function parseURLs(cssText) {\n    const urls = [];\n    cssText.replace(URL_REGEX, (raw, quotation, url) => {\n        urls.push(url);\n        return raw;\n    });\n    return urls.filter((url) => !isDataUrl(url));\n}\nexport async function embed(cssText, resourceURL, baseURL, options, getContentFromUrl) {\n    try {\n        const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL;\n        const contentType = getMimeType(resourceURL);\n        let dataURL;\n        if (getContentFromUrl) {\n            const content = await getContentFromUrl(resolvedURL);\n            dataURL = makeDataUrl(content, contentType);\n        }\n        else {\n            dataURL = await resourceToDataURL(resolvedURL, contentType, options);\n        }\n        return cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`);\n    }\n    catch (error) {\n        // pass\n    }\n    return cssText;\n}\nfunction filterPreferredFontFormat(str, { preferredFontFormat }) {\n    return !preferredFontFormat\n        ? str\n        : str.replace(FONT_SRC_REGEX, (match) => {\n            // eslint-disable-next-line no-constant-condition\n            while (true) {\n                const [src, , format] = URL_WITH_FORMAT_REGEX.exec(match) || [];\n                if (!format) {\n                    return '';\n                }\n                if (format === preferredFontFormat) {\n                    return `src: ${src};`;\n                }\n            }\n        });\n}\nexport function shouldEmbed(url) {\n    return url.search(URL_REGEX) !== -1;\n}\nexport async function embedResources(cssText, baseUrl, options) {\n    if (!shouldEmbed(cssText)) {\n        return cssText;\n    }\n    const filteredCSSText = filterPreferredFontFormat(cssText, options);\n    const urls = parseURLs(filteredCSSText);\n    return urls.reduce((deferred, url) => deferred.then((css) => embed(css, url, baseUrl, options)), Promise.resolve(filteredCSSText));\n}\n//# sourceMappingURL=embed-resources.js.map","import { Options } from './types'\nimport { resolveUrl } from './util'\nimport { getMimeType } from './mimes'\nimport { isDataUrl, makeDataUrl, resourceToDataURL } from './dataurl'\n\nconst URL_REGEX = /url\\((['\"]?)([^'\"]+?)\\1\\)/g\nconst URL_WITH_FORMAT_REGEX = /url\\([^)]+\\)\\s*format\\(([\"']?)([^\"']+)\\1\\)/g\nconst FONT_SRC_REGEX = /src:\\s*(?:url\\([^)]+\\)\\s*format\\([^)]+\\)[,;]\\s*)+/g\n\nfunction toRegex(url: string): RegExp {\n  // eslint-disable-next-line no-useless-escape\n  const escaped = url.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, '\\\\$1')\n  return new RegExp(`(url\\\\(['\"]?)(${escaped})(['\"]?\\\\))`, 'g')\n}\n\nexport function parseURLs(cssText: string): string[] {\n  const urls: string[] = []\n\n  cssText.replace(URL_REGEX, (raw, quotation, url) => {\n    urls.push(url)\n    return raw\n  })\n\n  return urls.filter((url) => !isDataUrl(url))\n}\n\nexport async function embed(\n  cssText: string,\n  resourceURL: string,\n  baseURL: string | null,\n  options: Options,\n  getContentFromUrl?: (url: string) => Promise<string>,\n): Promise<string> {\n  try {\n    const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL\n    const contentType = getMimeType(resourceURL)\n    let dataURL: string\n    if (getContentFromUrl) {\n      const content = await getContentFromUrl(resolvedURL)\n      dataURL = makeDataUrl(content, contentType)\n    } else {\n      dataURL = await resourceToDataURL(resolvedURL, contentType, options)\n    }\n    return cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`)\n  } catch (error) {\n    // pass\n  }\n  return cssText\n}\n\nfunction filterPreferredFontFormat(\n  str: string,\n  { preferredFontFormat }: Options,\n): string {\n  return !preferredFontFormat\n    ? str\n    : str.replace(FONT_SRC_REGEX, (match: string) => {\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n          const [src, , format] = URL_WITH_FORMAT_REGEX.exec(match) || []\n          if (!format) {\n            return ''\n          }\n\n          if (format === preferredFontFormat) {\n            return `src: ${src};`\n          }\n        }\n      })\n}\n\nexport function shouldEmbed(url: string): boolean {\n  return url.search(URL_REGEX) !== -1\n}\n\nexport async function embedResources(\n  cssText: string,\n  baseUrl: string | null,\n  options: Options,\n): Promise<string> {\n  if (!shouldEmbed(cssText)) {\n    return cssText\n  }\n\n  const filteredCSSText = filterPreferredFontFormat(cssText, options)\n  const urls = parseURLs(filteredCSSText)\n  return urls.reduce(\n    (deferred, url) =>\n      deferred.then((css) => embed(css, url, baseUrl, options)),\n    Promise.resolve(filteredCSSText),\n  )\n}\n","export function applyStyle(node, options) {\n    const { style } = node;\n    if (options.backgroundColor) {\n        style.backgroundColor = options.backgroundColor;\n    }\n    if (options.width) {\n        style.width = `${options.width}px`;\n    }\n    if (options.height) {\n        style.height = `${options.height}px`;\n    }\n    const manual = options.style;\n    if (manual != null) {\n        Object.keys(manual).forEach((key) => {\n            style[key] = manual[key];\n        });\n    }\n    return node;\n}\n//# sourceMappingURL=apply-style.js.map","import { Options } from './types'\n\nexport function applyStyle<T extends HTMLElement>(\n  node: T,\n  options: Options,\n): T {\n  const { style } = node\n\n  if (options.backgroundColor) {\n    style.backgroundColor = options.backgroundColor\n  }\n\n  if (options.width) {\n    style.width = `${options.width}px`\n  }\n\n  if (options.height) {\n    style.height = `${options.height}px`\n  }\n\n  const manual = options.style\n  if (manual != null) {\n    Object.keys(manual).forEach((key: any) => {\n      style[key] = manual[key] as string\n    })\n  }\n\n  return node\n}\n","import { toArray } from './util';\nimport { fetchAsDataURL } from './dataurl';\nimport { shouldEmbed, embedResources } from './embed-resources';\nconst cssFetchCache = {};\nasync function fetchCSS(url) {\n    let cache = cssFetchCache[url];\n    if (cache != null) {\n        return cache;\n    }\n    const res = await fetch(url);\n    const cssText = await res.text();\n    cache = { url, cssText };\n    cssFetchCache[url] = cache;\n    return cache;\n}\nasync function embedFonts(data, options) {\n    let cssText = data.cssText;\n    const regexUrl = /url\\([\"']?([^\"')]+)[\"']?\\)/g;\n    const fontLocs = cssText.match(/url\\([^)]+\\)/g) || [];\n    const loadFonts = fontLocs.map(async (loc) => {\n        let url = loc.replace(regexUrl, '$1');\n        if (!url.startsWith('https://')) {\n            url = new URL(url, data.url).href;\n        }\n        return fetchAsDataURL(url, options.fetchRequestInit, ({ result }) => {\n            cssText = cssText.replace(loc, `url(${result})`);\n            return [loc, result];\n        });\n    });\n    return Promise.all(loadFonts).then(() => cssText);\n}\nfunction parseCSS(source) {\n    if (source == null) {\n        return [];\n    }\n    const result = [];\n    const commentsRegex = /(\\/\\*[\\s\\S]*?\\*\\/)/gi;\n    // strip out comments\n    let cssText = source.replace(commentsRegex, '');\n    // eslint-disable-next-line prefer-regex-literals\n    const keyframesRegex = new RegExp('((@.*?keyframes [\\\\s\\\\S]*?){([\\\\s\\\\S]*?}\\\\s*?)})', 'gi');\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        const matches = keyframesRegex.exec(cssText);\n        if (matches === null) {\n            break;\n        }\n        result.push(matches[0]);\n    }\n    cssText = cssText.replace(keyframesRegex, '');\n    const importRegex = /@import[\\s\\S]*?url\\([^)]*\\)[\\s\\S]*?;/gi;\n    // to match css & media queries together\n    const combinedCSSRegex = '((\\\\s*?(?:\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/)?\\\\s*?@media[\\\\s\\\\S]' +\n        '*?){([\\\\s\\\\S]*?)}\\\\s*?})|(([\\\\s\\\\S]*?){([\\\\s\\\\S]*?)})';\n    // unified regex\n    const unifiedRegex = new RegExp(combinedCSSRegex, 'gi');\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        let matches = importRegex.exec(cssText);\n        if (matches === null) {\n            matches = unifiedRegex.exec(cssText);\n            if (matches === null) {\n                break;\n            }\n            else {\n                importRegex.lastIndex = unifiedRegex.lastIndex;\n            }\n        }\n        else {\n            unifiedRegex.lastIndex = importRegex.lastIndex;\n        }\n        result.push(matches[0]);\n    }\n    return result;\n}\nasync function getCSSRules(styleSheets, options) {\n    const ret = [];\n    const deferreds = [];\n    // First loop inlines imports\n    styleSheets.forEach((sheet) => {\n        if ('cssRules' in sheet) {\n            try {\n                toArray(sheet.cssRules || []).forEach((item, index) => {\n                    if (item.type === CSSRule.IMPORT_RULE) {\n                        let importIndex = index + 1;\n                        const url = item.href;\n                        const deferred = fetchCSS(url)\n                            .then((metadata) => embedFonts(metadata, options))\n                            .then((cssText) => parseCSS(cssText).forEach((rule) => {\n                            try {\n                                sheet.insertRule(rule, rule.startsWith('@import')\n                                    ? (importIndex += 1)\n                                    : sheet.cssRules.length);\n                            }\n                            catch (error) {\n                                console.error('Error inserting rule from remote css', {\n                                    rule,\n                                    error,\n                                });\n                            }\n                        }))\n                            .catch((e) => {\n                            console.error('Error loading remote css', e.toString());\n                        });\n                        deferreds.push(deferred);\n                    }\n                });\n            }\n            catch (e) {\n                const inline = styleSheets.find((a) => a.href == null) || document.styleSheets[0];\n                if (sheet.href != null) {\n                    deferreds.push(fetchCSS(sheet.href)\n                        .then((metadata) => embedFonts(metadata, options))\n                        .then((cssText) => parseCSS(cssText).forEach((rule) => {\n                        inline.insertRule(rule, sheet.cssRules.length);\n                    }))\n                        .catch((err) => {\n                        console.error('Error loading remote stylesheet', err);\n                    }));\n                }\n                console.error('Error inlining remote css file', e);\n            }\n        }\n    });\n    return Promise.all(deferreds).then(() => {\n        // Second loop parses rules\n        styleSheets.forEach((sheet) => {\n            if ('cssRules' in sheet) {\n                try {\n                    toArray(sheet.cssRules || []).forEach((item) => {\n                        ret.push(item);\n                    });\n                }\n                catch (e) {\n                    console.error(`Error while reading CSS rules from ${sheet.href}`, e);\n                }\n            }\n        });\n        return ret;\n    });\n}\nfunction getWebFontRules(cssRules) {\n    return cssRules\n        .filter((rule) => rule.type === CSSRule.FONT_FACE_RULE)\n        .filter((rule) => shouldEmbed(rule.style.getPropertyValue('src')));\n}\nasync function parseWebFontRules(node, options) {\n    if (node.ownerDocument == null) {\n        throw new Error('Provided element is not within a Document');\n    }\n    const styleSheets = toArray(node.ownerDocument.styleSheets);\n    const cssRules = await getCSSRules(styleSheets, options);\n    return getWebFontRules(cssRules);\n}\nexport async function getWebFontCSS(node, options) {\n    const rules = await parseWebFontRules(node, options);\n    const cssTexts = await Promise.all(rules.map((rule) => {\n        const baseUrl = rule.parentStyleSheet ? rule.parentStyleSheet.href : null;\n        return embedResources(rule.cssText, baseUrl, options);\n    }));\n    return cssTexts.join('\\n');\n}\nexport async function embedWebFonts(clonedNode, options) {\n    const cssText = options.fontEmbedCSS != null\n        ? options.fontEmbedCSS\n        : options.skipFonts\n            ? null\n            : await getWebFontCSS(clonedNode, options);\n    if (cssText) {\n        const styleNode = document.createElement('style');\n        const sytleContent = document.createTextNode(cssText);\n        styleNode.appendChild(sytleContent);\n        if (clonedNode.firstChild) {\n            clonedNode.insertBefore(styleNode, clonedNode.firstChild);\n        }\n        else {\n            clonedNode.appendChild(styleNode);\n        }\n    }\n}\n//# sourceMappingURL=embed-webfonts.js.map","import type { Options } from './types'\nimport { toArray } from './util'\nimport { fetchAsDataURL } from './dataurl'\nimport { shouldEmbed, embedResources } from './embed-resources'\n\ninterface Metadata {\n  url: string\n  cssText: string\n}\n\nconst cssFetchCache: { [href: string]: Metadata } = {}\n\nasync function fetchCSS(url: string) {\n  let cache = cssFetchCache[url]\n  if (cache != null) {\n    return cache\n  }\n\n  const res = await fetch(url)\n  const cssText = await res.text()\n  cache = { url, cssText }\n\n  cssFetchCache[url] = cache\n\n  return cache\n}\n\nasync function embedFonts(data: Metadata, options: Options): Promise<string> {\n  let cssText = data.cssText\n  const regexUrl = /url\\([\"']?([^\"')]+)[\"']?\\)/g\n  const fontLocs = cssText.match(/url\\([^)]+\\)/g) || []\n  const loadFonts = fontLocs.map(async (loc: string) => {\n    let url = loc.replace(regexUrl, '$1')\n    if (!url.startsWith('https://')) {\n      url = new URL(url, data.url).href\n    }\n\n    return fetchAsDataURL<[string, string]>(\n      url,\n      options.fetchRequestInit,\n      ({ result }) => {\n        cssText = cssText.replace(loc, `url(${result})`)\n        return [loc, result]\n      },\n    )\n  })\n\n  return Promise.all(loadFonts).then(() => cssText)\n}\n\nfunction parseCSS(source: string) {\n  if (source == null) {\n    return []\n  }\n\n  const result: string[] = []\n  const commentsRegex = /(\\/\\*[\\s\\S]*?\\*\\/)/gi\n  // strip out comments\n  let cssText = source.replace(commentsRegex, '')\n\n  // eslint-disable-next-line prefer-regex-literals\n  const keyframesRegex = new RegExp(\n    '((@.*?keyframes [\\\\s\\\\S]*?){([\\\\s\\\\S]*?}\\\\s*?)})',\n    'gi',\n  )\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const matches = keyframesRegex.exec(cssText)\n    if (matches === null) {\n      break\n    }\n    result.push(matches[0])\n  }\n  cssText = cssText.replace(keyframesRegex, '')\n\n  const importRegex = /@import[\\s\\S]*?url\\([^)]*\\)[\\s\\S]*?;/gi\n  // to match css & media queries together\n  const combinedCSSRegex =\n    '((\\\\s*?(?:\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/)?\\\\s*?@media[\\\\s\\\\S]' +\n    '*?){([\\\\s\\\\S]*?)}\\\\s*?})|(([\\\\s\\\\S]*?){([\\\\s\\\\S]*?)})'\n  // unified regex\n  const unifiedRegex = new RegExp(combinedCSSRegex, 'gi')\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let matches = importRegex.exec(cssText)\n    if (matches === null) {\n      matches = unifiedRegex.exec(cssText)\n      if (matches === null) {\n        break\n      } else {\n        importRegex.lastIndex = unifiedRegex.lastIndex\n      }\n    } else {\n      unifiedRegex.lastIndex = importRegex.lastIndex\n    }\n    result.push(matches[0])\n  }\n\n  return result\n}\n\nasync function getCSSRules(\n  styleSheets: CSSStyleSheet[],\n  options: Options,\n): Promise<CSSStyleRule[]> {\n  const ret: CSSStyleRule[] = []\n  const deferreds: Promise<number | void>[] = []\n\n  // First loop inlines imports\n  styleSheets.forEach((sheet) => {\n    if ('cssRules' in sheet) {\n      try {\n        toArray<CSSRule>(sheet.cssRules || []).forEach((item, index) => {\n          if (item.type === CSSRule.IMPORT_RULE) {\n            let importIndex = index + 1\n            const url = (item as CSSImportRule).href\n            const deferred = fetchCSS(url)\n              .then((metadata) => embedFonts(metadata, options))\n              .then((cssText) =>\n                parseCSS(cssText).forEach((rule) => {\n                  try {\n                    sheet.insertRule(\n                      rule,\n                      rule.startsWith('@import')\n                        ? (importIndex += 1)\n                        : sheet.cssRules.length,\n                    )\n                  } catch (error) {\n                    console.error('Error inserting rule from remote css', {\n                      rule,\n                      error,\n                    })\n                  }\n                }),\n              )\n              .catch((e) => {\n                console.error('Error loading remote css', e.toString())\n              })\n\n            deferreds.push(deferred)\n          }\n        })\n      } catch (e) {\n        const inline =\n          styleSheets.find((a) => a.href == null) || document.styleSheets[0]\n        if (sheet.href != null) {\n          deferreds.push(\n            fetchCSS(sheet.href)\n              .then((metadata) => embedFonts(metadata, options))\n              .then((cssText) =>\n                parseCSS(cssText).forEach((rule) => {\n                  inline.insertRule(rule, sheet.cssRules.length)\n                }),\n              )\n              .catch((err: unknown) => {\n                console.error('Error loading remote stylesheet', err)\n              }),\n          )\n        }\n        console.error('Error inlining remote css file', e)\n      }\n    }\n  })\n\n  return Promise.all(deferreds).then(() => {\n    // Second loop parses rules\n    styleSheets.forEach((sheet) => {\n      if ('cssRules' in sheet) {\n        try {\n          toArray<CSSStyleRule>(sheet.cssRules || []).forEach((item) => {\n            ret.push(item)\n          })\n        } catch (e) {\n          console.error(`Error while reading CSS rules from ${sheet.href}`, e)\n        }\n      }\n    })\n\n    return ret\n  })\n}\n\nfunction getWebFontRules(cssRules: CSSStyleRule[]): CSSStyleRule[] {\n  return cssRules\n    .filter((rule) => rule.type === CSSRule.FONT_FACE_RULE)\n    .filter((rule) => shouldEmbed(rule.style.getPropertyValue('src')))\n}\n\nasync function parseWebFontRules<T extends HTMLElement>(\n  node: T,\n  options: Options,\n) {\n  if (node.ownerDocument == null) {\n    throw new Error('Provided element is not within a Document')\n  }\n\n  const styleSheets = toArray<CSSStyleSheet>(node.ownerDocument.styleSheets)\n  const cssRules = await getCSSRules(styleSheets, options)\n\n  return getWebFontRules(cssRules)\n}\n\nexport async function getWebFontCSS<T extends HTMLElement>(\n  node: T,\n  options: Options,\n): Promise<string> {\n  const rules = await parseWebFontRules(node, options)\n  const cssTexts = await Promise.all(\n    rules.map((rule) => {\n      const baseUrl = rule.parentStyleSheet ? rule.parentStyleSheet.href : null\n      return embedResources(rule.cssText, baseUrl, options)\n    }),\n  )\n\n  return cssTexts.join('\\n')\n}\n\nexport async function embedWebFonts<T extends HTMLElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  const cssText =\n    options.fontEmbedCSS != null\n      ? options.fontEmbedCSS\n      : options.skipFonts\n      ? null\n      : await getWebFontCSS(clonedNode, options)\n\n  if (cssText) {\n    const styleNode = document.createElement('style')\n    const sytleContent = document.createTextNode(cssText)\n\n    styleNode.appendChild(sytleContent)\n\n    if (clonedNode.firstChild) {\n      clonedNode.insertBefore(styleNode, clonedNode.firstChild)\n    } else {\n      clonedNode.appendChild(styleNode)\n    }\n  }\n}\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$d3c1734dacb01657$var$cachedSetTimeout","$d3c1734dacb01657$var$cachedClearTimeout","$d3c1734dacb01657$var$currentQueue","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$b6370854aea1ab9c$export$87e24ddbab2613d9","DOM_SHOT_EXT_ACTION","$b6370854aea1ab9c$export$14333815d08d1368","$b6370854aea1ab9c$export$1626c9497abbc183","$c498bb1c05d876ef$export$c2baa37b6f53c8a6","$c498bb1c05d876ef$export$3c628e933563550d","$c498bb1c05d876ef$export$3ff6e4654a09dfa4","$c498bb1c05d876ef$export$a2b6a13999826ac7","$d0TNe","$hsKA8","action","payload","console","log","window","postMessage","source","DOM_SHOT_EXT_NAME","message","optionalParams","error","version","buildTime","JSON","parse","$afMVx","$d3c1734dacb01657$exports","$d3c1734dacb01657$var$process","$d3c1734dacb01657$var$defaultSetTimout","$d3c1734dacb01657$var$defaultClearTimeout","$d3c1734dacb01657$var$runTimeout","fun","setTimeout","clearTimeout","$d3c1734dacb01657$var$queue","$d3c1734dacb01657$var$draining","$d3c1734dacb01657$var$queueIndex","$d3c1734dacb01657$var$cleanUpNextTick","length","concat","$d3c1734dacb01657$var$drainQueue","timeout","len","run","$d3c1734dacb01657$var$runClearTimeout","marker","$d3c1734dacb01657$var$Item","array","$d3c1734dacb01657$var$noop","nextTick","args","Array","arguments","i","push","prototype","apply","title","browser","env","argv","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","$3f38c4817eb4f38b$export$31b40729666a4ae0","counter","random","Math","toString","slice","$3f38c4817eb4f38b$export$45b10814cc054894","arrayLike","arr","l","$3f38c4817eb4f38b$var$px","node","styleProperty","val","win","ownerDocument","defaultView","getComputedStyle","getPropertyValue","parseFloat","replace","$3f38c4817eb4f38b$export$ada5537b2c061996","targetNode","options","width","$3f38c4817eb4f38b$var$getNodeWidth","leftBorder","rightBorder","clientWidth","height","$3f38c4817eb4f38b$var$getNodeHeight","topBorder","bottomBorder","clientHeight","$3f38c4817eb4f38b$export$ec664d7487540b","url","Promise","resolve","reject","img","Image","decode","onload","onerror","crossOrigin","decoding","src","$3f38c4817eb4f38b$export$fe77aa9c02de4599","svg","then","XMLSerializer","serializeToString","encodeURIComponent","html","$3f38c4817eb4f38b$export$b62810fb8ca515fa","xmlns","document","createElementNS","foreignObject","setAttribute","appendChild","$3f38c4817eb4f38b$export$3a92fc9ec83ef360","instance","nodePrototype","getPrototypeOf","constructor","$5dc335fc18f5c31c$var$clonePseudoElement","nativeNode","clonedNode","pseudo","style","content","className","styleElement","createElement","$5dc335fc18f5c31c$var$getPseudoElementStyle","selector","cssText","$5dc335fc18f5c31c$var$formatCSSText","map","value","priority","getPropertyPriority","join","createTextNode","$932a96ce56c3bc50$var$WOFF","$932a96ce56c3bc50$var$JPEG","$932a96ce56c3bc50$var$mimes","woff","woff2","ttf","eot","png","jpg","jpeg","gif","tiff","webp","$932a96ce56c3bc50$export$200548c990602f61","$932a96ce56c3bc50$var$getExtension","match","exec","toLowerCase","$36f8c7f53bd1328c$export$f8a05efa20ffd5a","search","$36f8c7f53bd1328c$export$68336ea1617fa80a","mimeType","$36f8c7f53bd1328c$export$c20a8b76c95b0d41","process","res","fetch","status","blob","reader","FileReader","onloadend","result","readAsDataURL","$36f8c7f53bd1328c$var$cache","$36f8c7f53bd1328c$export$bdf0422c029b202a","resourceUrl","contentType","includeQueryParams","dataURL","key","cacheKey","test","cacheBust","Date","getTime","fetchRequestInit","headers","split","imagePlaceholder","msg","warn","$e4993691940aed80$var$cloneCanvasElement","canvas","toDataURL","cloneNode","$e4993691940aed80$var$cloneVideoElement","video","currentSrc","ctx","getContext","drawImage","poster","$e4993691940aed80$var$cloneIFrameElement","iframe","_a","contentDocument","body","$e4993691940aed80$export$ae8e35ea29ddac22","_b","$e4993691940aed80$var$cloneSingleNode","HTMLCanvasElement","HTMLVideoElement","HTMLIFrameElement","$e4993691940aed80$var$isSlotElement","tagName","toUpperCase","$e4993691940aed80$var$cloneChildren","children","assignedNodes","childNodes","shadowRoot","reduce","deferred","child","clonedChild","$e4993691940aed80$var$ensureSVGSymbols","clone","uses","querySelectorAll","processedDefs","use","getAttribute","exist","querySelector","definition","nodes","values","ns","position","overflow","display","defs","isRoot","filter","Element","$e4993691940aed80$var$cloneCSSStyle","targetStyle","sourceStyle","transformOrigin","forEach","endsWith","reducedFont","floor","substring","setProperty","HTMLTextAreaElement","innerHTML","HTMLInputElement","$e4993691940aed80$var$cloneSelectValue","HTMLSelectElement","selectedOption","from","clonedSelect","find","$6f23389cdbe0dece$var$URL_REGEX","$6f23389cdbe0dece$var$URL_WITH_FORMAT_REGEX","$6f23389cdbe0dece$var$FONT_SRC_REGEX","$6f23389cdbe0dece$export$2be46bb7e96db87f","resourceURL","baseURL","getContentFromUrl","resolvedURL","baseUrl","location","protocol","doc","implementation","createHTMLDocument","base","a","head","href","$6f23389cdbe0dece$var$toRegex","escaped","RegExp","$6f23389cdbe0dece$export$7b668369e5eab853","$6f23389cdbe0dece$export$3d88803585cbbc21","filteredCSSText","$6f23389cdbe0dece$var$filterPreferredFontFormat","str","preferredFontFormat","format","urls","$6f23389cdbe0dece$export$d04549d631b8762d","raw","quotation","css","$d00e8710aa74d8f2$var$embedProp","propName","propValue","cssString","$d00e8710aa74d8f2$var$embedBackground","$d00e8710aa74d8f2$var$embedImageNode","isImageElement","HTMLImageElement","SVGImageElement","baseVal","image","loading","srcset","$d00e8710aa74d8f2$var$embedChildren","deferreds","$d00e8710aa74d8f2$export$6660fa8dd20e53aa","all","$e00ffe9f0e6cf773$var$cssFetchCache","$e00ffe9f0e6cf773$var$fetchCSS","cache","text","$e00ffe9f0e6cf773$var$embedFonts","data","regexUrl","fontLocs","loc","startsWith","URL","$e00ffe9f0e6cf773$var$parseCSS","keyframesRegex","matches","importRegex","unifiedRegex","lastIndex","$e00ffe9f0e6cf773$var$getCSSRules","styleSheets","ret","sheet","cssRules","item","index","type","CSSRule","IMPORT_RULE","importIndex","metadata","rule","insertRule","catch","inline","$e00ffe9f0e6cf773$var$parseWebFontRules","FONT_FACE_RULE","$e00ffe9f0e6cf773$export$253c9aa3d83a57b6","rules","cssTexts","parentStyleSheet","$e00ffe9f0e6cf773$export$2c2c83b77c8cb421","fontEmbedCSS","skipFonts","styleNode","sytleContent","firstChild","insertBefore","$49e912db89b35827$export$20d300cb2d558b7","backgroundColor","manual","keys","$49e912db89b35827$export$f87f6982d1fd4f81","context","ratio","pixelRatio","FINAL_PROCESS","devicePixelRatio","Number","isNaN","parseInt","canvasWidth","canvasHeight","skipAutoScale","$3f38c4817eb4f38b$var$canvasDimensionLimit","fillStyle","fillRect","$49e912db89b35827$export$aba256f33615c92e","$048c0dc54e08960c$export$4778991634f78fa5","domShotLog","element","domShotError","$048c0dc54e08960c$var$replaceImagesInDOM","imgData","DOM_SHOT_EXT_BG_NAME","domShot","domElement","elements","hasAttribute","backgroundImage","$048c0dc54e08960c$var$replaceImage","imgElement","$24add57b2feb7361$var$DOM_SHOT_HELPER_KEY","helper","tabId","clearEvent","initUtils","domShotVersion","messageHandler","event","utilsActionMap","removeEventListener","addEventListener"],"version":3,"file":"helper.js.map"}