{"mappings":"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","sources":["<anon>","src/helper.ts","src/utils/constant.ts","src/utils/index.ts","package.json","src/utils/dom.ts","node_modules/html-to-image/es/index.js","node_modules/html-to-image/src/index.ts","node_modules/html-to-image/es/clone-node.js","node_modules/html-to-image/src/clone-node.ts","node_modules/html-to-image/es/clone-pseudos.js","node_modules/html-to-image/src/clone-pseudos.ts","node_modules/html-to-image/es/util.js","node_modules/html-to-image/src/util.ts","node_modules/process/browser.js","node_modules/html-to-image/es/mimes.js","node_modules/html-to-image/src/mimes.ts","node_modules/html-to-image/es/dataurl.js","node_modules/html-to-image/src/dataurl.ts","node_modules/html-to-image/es/embed-images.js","node_modules/html-to-image/src/embed-images.ts","node_modules/html-to-image/es/embed-resources.js","node_modules/html-to-image/src/embed-resources.ts","node_modules/html-to-image/es/apply-style.js","node_modules/html-to-image/src/apply-style.ts","node_modules/html-to-image/es/embed-webfonts.js","node_modules/html-to-image/src/embed-webfonts.ts"],"sourcesContent":["(() => {\nconst $b6370854aea1ab9c$export$14333815d08d1368 = \"dom_shot_chrome_extension\";\nvar $b6370854aea1ab9c$export$87e24ddbab2613d9;\n(function(DOM_SHOT_EXT_ACTION) {\n    DOM_SHOT_EXT_ACTION[DOM_SHOT_EXT_ACTION[\"ready\"] = 0] = \"ready\";\n    DOM_SHOT_EXT_ACTION[DOM_SHOT_EXT_ACTION[\"domShot\"] = 1] = \"domShot\";\n})($b6370854aea1ab9c$export$87e24ddbab2613d9 || ($b6370854aea1ab9c$export$87e24ddbab2613d9 = {}));\n\n\n\nvar $cb692f5b2b7518ec$exports = {};\n$cb692f5b2b7518ec$exports = JSON.parse('{\"name\":\"dom-shot-chrome-extension\",\"version\":\"2.2.7\",\"buildTime\":\"2024-07-26\",\"source\":\"src/index.html\",\"description\":\"dom-shot-chrome-extension\",\"dependencies\":{\"clsx\":\"^1.2.1\",\"dayjs\":\"^1.11.7\",\"html-to-image\":\"^1.11.11\",\"mobx\":\"^6.12.3\",\"react\":\"^18.2.0\",\"react-dom\":\"^18.2.0\",\"react-draggable\":\"^4.4.6\",\"react-select\":\"^5.7.7\"},\"devDependencies\":{\"@parcel/transformer-less\":\"^2.9.3\",\"@types/node\":\"^20.6.5\",\"@types/react\":\"18.0\",\"@types/react-dom\":\"18.0\",\"chrome-types\":\"^0.1.231\",\"html2canvas\":\"^1.4.1\",\"parcel\":\"^2.8.3\",\"postcss\":\"^8.4.30\",\"postcss-modules\":\"^4.3.1\",\"process\":\"^0.11.10\"},\"scripts\":{\"start\":\"parcel src/index.tsx src/popup.html  --no-cache\",\"start:bg\":\"parcel build src/background.ts --no-cache\",\"build\":\"rm -rf dist/; parcel build src/background.ts src/helper.ts src/index.tsx src/devtools.html src/sidebar.html --no-content-hash --no-cache;sh deploy.sh\",\"test\":\"echo \\\\\"Error: no test specified\\\\\" && exit 1\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://gitlab.temu.team/dawn.tang/dom-shot-chrome-extension.git\"},\"keywords\":[],\"author\":\"\",\"license\":\"ISC\",\"bugs\":{\"url\":\"https://gitlab.temu.team/dawn.tang/dom-shot-chrome-extension/-/issues\"},\"homepage\":\"https://gitlab.temu.team/dawn.tang/dom-shot-chrome-extension\"}');\n\n\nconst $c498bb1c05d876ef$export$40edfb7eeb78c4e8 = ()=>{\n    return false;\n};\nconst $c498bb1c05d876ef$export$edd07609368c8939 = async (timeout = 0)=>{\n    return new Promise((resolve)=>setTimeout(()=>resolve(true), timeout));\n};\nconst $c498bb1c05d876ef$export$c2baa37b6f53c8a6 = (action, payload)=>{\n    window.postMessage({\n        source: (0, $b6370854aea1ab9c$export$14333815d08d1368),\n        action: action,\n        payload: payload\n    }, \"*\");\n};\nconst $c498bb1c05d876ef$export$3c628e933563550d = (message, ...optionalParams)=>{\n    console.log(\"[\\uD83D\\uDD38DOM_SHOT\\uD83D\\uDD38]\", message, ...optionalParams);\n};\nconst $c498bb1c05d876ef$export$3ff6e4654a09dfa4 = (message, ...optionalParams)=>{\n    console.error(\"[\\uD83D\\uDD38DOM_SHOT\\uD83D\\uDD38]\", message, ...optionalParams);\n};\nconst $c498bb1c05d876ef$export$a2b6a13999826ac7 = ()=>{\n    console.log(`[üî∏DOM_SHOTüî∏] Êèí‰ª∂ÁâàÊú¨%c v${(0, $cb692f5b2b7518ec$exports.version)} at ${(0, $cb692f5b2b7518ec$exports.buildTime)}`, \"color: orange;\");\n};\n\n\nvar $d3c1734dacb01657$exports = {};\n// shim for using process in browser\nvar $d3c1734dacb01657$var$process = $d3c1734dacb01657$exports = {};\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\nvar $d3c1734dacb01657$var$cachedSetTimeout;\nvar $d3c1734dacb01657$var$cachedClearTimeout;\nfunction $d3c1734dacb01657$var$defaultSetTimout() {\n    throw new Error(\"setTimeout has not been defined\");\n}\nfunction $d3c1734dacb01657$var$defaultClearTimeout() {\n    throw new Error(\"clearTimeout has not been defined\");\n}\n(function() {\n    try {\n        if (typeof setTimeout === \"function\") $d3c1734dacb01657$var$cachedSetTimeout = setTimeout;\n        else $d3c1734dacb01657$var$cachedSetTimeout = $d3c1734dacb01657$var$defaultSetTimout;\n    } catch (e) {\n        $d3c1734dacb01657$var$cachedSetTimeout = $d3c1734dacb01657$var$defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === \"function\") $d3c1734dacb01657$var$cachedClearTimeout = clearTimeout;\n        else $d3c1734dacb01657$var$cachedClearTimeout = $d3c1734dacb01657$var$defaultClearTimeout;\n    } catch (e) {\n        $d3c1734dacb01657$var$cachedClearTimeout = $d3c1734dacb01657$var$defaultClearTimeout;\n    }\n})();\nfunction $d3c1734dacb01657$var$runTimeout(fun) {\n    if ($d3c1734dacb01657$var$cachedSetTimeout === setTimeout) //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n    // if setTimeout wasn't available but was latter defined\n    if (($d3c1734dacb01657$var$cachedSetTimeout === $d3c1734dacb01657$var$defaultSetTimout || !$d3c1734dacb01657$var$cachedSetTimeout) && setTimeout) {\n        $d3c1734dacb01657$var$cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return $d3c1734dacb01657$var$cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return $d3c1734dacb01657$var$cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return $d3c1734dacb01657$var$cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction $d3c1734dacb01657$var$runClearTimeout(marker) {\n    if ($d3c1734dacb01657$var$cachedClearTimeout === clearTimeout) //normal enviroments in sane situations\n    return clearTimeout(marker);\n    // if clearTimeout wasn't available but was latter defined\n    if (($d3c1734dacb01657$var$cachedClearTimeout === $d3c1734dacb01657$var$defaultClearTimeout || !$d3c1734dacb01657$var$cachedClearTimeout) && clearTimeout) {\n        $d3c1734dacb01657$var$cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return $d3c1734dacb01657$var$cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return $d3c1734dacb01657$var$cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return $d3c1734dacb01657$var$cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar $d3c1734dacb01657$var$queue = [];\nvar $d3c1734dacb01657$var$draining = false;\nvar $d3c1734dacb01657$var$currentQueue;\nvar $d3c1734dacb01657$var$queueIndex = -1;\nfunction $d3c1734dacb01657$var$cleanUpNextTick() {\n    if (!$d3c1734dacb01657$var$draining || !$d3c1734dacb01657$var$currentQueue) return;\n    $d3c1734dacb01657$var$draining = false;\n    if ($d3c1734dacb01657$var$currentQueue.length) $d3c1734dacb01657$var$queue = $d3c1734dacb01657$var$currentQueue.concat($d3c1734dacb01657$var$queue);\n    else $d3c1734dacb01657$var$queueIndex = -1;\n    if ($d3c1734dacb01657$var$queue.length) $d3c1734dacb01657$var$drainQueue();\n}\nfunction $d3c1734dacb01657$var$drainQueue() {\n    if ($d3c1734dacb01657$var$draining) return;\n    var timeout = $d3c1734dacb01657$var$runTimeout($d3c1734dacb01657$var$cleanUpNextTick);\n    $d3c1734dacb01657$var$draining = true;\n    var len = $d3c1734dacb01657$var$queue.length;\n    while(len){\n        $d3c1734dacb01657$var$currentQueue = $d3c1734dacb01657$var$queue;\n        $d3c1734dacb01657$var$queue = [];\n        while(++$d3c1734dacb01657$var$queueIndex < len)if ($d3c1734dacb01657$var$currentQueue) $d3c1734dacb01657$var$currentQueue[$d3c1734dacb01657$var$queueIndex].run();\n        $d3c1734dacb01657$var$queueIndex = -1;\n        len = $d3c1734dacb01657$var$queue.length;\n    }\n    $d3c1734dacb01657$var$currentQueue = null;\n    $d3c1734dacb01657$var$draining = false;\n    $d3c1734dacb01657$var$runClearTimeout(timeout);\n}\n$d3c1734dacb01657$var$process.nextTick = function(fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];\n    $d3c1734dacb01657$var$queue.push(new $d3c1734dacb01657$var$Item(fun, args));\n    if ($d3c1734dacb01657$var$queue.length === 1 && !$d3c1734dacb01657$var$draining) $d3c1734dacb01657$var$runTimeout($d3c1734dacb01657$var$drainQueue);\n};\n// v8 likes predictible objects\nfunction $d3c1734dacb01657$var$Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\n$d3c1734dacb01657$var$Item.prototype.run = function() {\n    this.fun.apply(null, this.array);\n};\n$d3c1734dacb01657$var$process.title = \"browser\";\n$d3c1734dacb01657$var$process.browser = true;\n$d3c1734dacb01657$var$process.env = {};\n$d3c1734dacb01657$var$process.argv = [];\n$d3c1734dacb01657$var$process.version = \"\"; // empty string to avoid regexp issues\n$d3c1734dacb01657$var$process.versions = {};\nfunction $d3c1734dacb01657$var$noop() {}\n$d3c1734dacb01657$var$process.on = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.addListener = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.once = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.off = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.removeListener = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.removeAllListeners = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.emit = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.prependListener = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.prependOnceListener = $d3c1734dacb01657$var$noop;\n$d3c1734dacb01657$var$process.listeners = function(name) {\n    return [];\n};\n$d3c1734dacb01657$var$process.binding = function(name) {\n    throw new Error(\"process.binding is not supported\");\n};\n$d3c1734dacb01657$var$process.cwd = function() {\n    return \"/\";\n};\n$d3c1734dacb01657$var$process.chdir = function(dir) {\n    throw new Error(\"process.chdir is not supported\");\n};\n$d3c1734dacb01657$var$process.umask = function() {\n    return 0;\n};\n\n\nfunction $3f38c4817eb4f38b$export$f85c16a6d62f7d63(url, baseUrl) {\n    // url is absolute already\n    if (url.match(/^[a-z]+:\\/\\//i)) return url;\n    // url is absolute already, without protocol\n    if (url.match(/^\\/\\//)) return window.location.protocol + url;\n    // dataURI, mailto:, tel:, etc.\n    if (url.match(/^[a-z]+:/i)) return url;\n    const doc = document.implementation.createHTMLDocument();\n    const base = doc.createElement(\"base\");\n    const a = doc.createElement(\"a\");\n    doc.head.appendChild(base);\n    doc.body.appendChild(a);\n    if (baseUrl) base.href = baseUrl;\n    a.href = url;\n    return a.href;\n}\nconst $3f38c4817eb4f38b$export$31b40729666a4ae0 = (()=>{\n    // generate uuid for className of pseudo elements.\n    // We should not use GUIDs, otherwise pseudo elements sometimes cannot be captured.\n    let counter = 0;\n    // ref: http://stackoverflow.com/a/6248722/2519373\n    const random = ()=>// eslint-disable-next-line no-bitwise\n        `0000${(Math.random() * 36 ** 4 << 0).toString(36)}`.slice(-4);\n    return ()=>{\n        counter += 1;\n        return `u${random()}${counter}`;\n    };\n})();\nfunction $3f38c4817eb4f38b$export$1391212d75b2ee65(ms) {\n    return (args)=>new Promise((resolve)=>{\n            setTimeout(()=>resolve(args), ms);\n        });\n}\nfunction $3f38c4817eb4f38b$export$45b10814cc054894(arrayLike) {\n    const arr = [];\n    for(let i = 0, l = arrayLike.length; i < l; i++)arr.push(arrayLike[i]);\n    return arr;\n}\nfunction $3f38c4817eb4f38b$var$px(node, styleProperty) {\n    const win = node.ownerDocument.defaultView || window;\n    const val = win.getComputedStyle(node).getPropertyValue(styleProperty);\n    return val ? parseFloat(val.replace(\"px\", \"\")) : 0;\n}\nfunction $3f38c4817eb4f38b$var$getNodeWidth(node) {\n    const leftBorder = $3f38c4817eb4f38b$var$px(node, \"border-left-width\");\n    const rightBorder = $3f38c4817eb4f38b$var$px(node, \"border-right-width\");\n    return node.clientWidth + leftBorder + rightBorder;\n}\nfunction $3f38c4817eb4f38b$var$getNodeHeight(node) {\n    const topBorder = $3f38c4817eb4f38b$var$px(node, \"border-top-width\");\n    const bottomBorder = $3f38c4817eb4f38b$var$px(node, \"border-bottom-width\");\n    return node.clientHeight + topBorder + bottomBorder;\n}\nfunction $3f38c4817eb4f38b$export$ada5537b2c061996(targetNode, options = {}) {\n    const width = options.width || $3f38c4817eb4f38b$var$getNodeWidth(targetNode);\n    const height = options.height || $3f38c4817eb4f38b$var$getNodeHeight(targetNode);\n    return {\n        width: width,\n        height: height\n    };\n}\nfunction $3f38c4817eb4f38b$export$d39ce20a37bba061() {\n    let ratio;\n    let FINAL_PROCESS;\n    try {\n        FINAL_PROCESS = $d3c1734dacb01657$exports;\n    } catch (e) {\n    // pass\n    }\n    const val = FINAL_PROCESS && FINAL_PROCESS.env ? FINAL_PROCESS.env.devicePixelRatio : null;\n    if (val) {\n        ratio = parseInt(val, 10);\n        if (Number.isNaN(ratio)) ratio = 1;\n    }\n    return ratio || window.devicePixelRatio || 1;\n}\n// @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas#maximum_canvas_size\nconst $3f38c4817eb4f38b$var$canvasDimensionLimit = 16384;\nfunction $3f38c4817eb4f38b$export$c2c809a2fe6b0f1a(canvas) {\n    if (canvas.width > $3f38c4817eb4f38b$var$canvasDimensionLimit || canvas.height > $3f38c4817eb4f38b$var$canvasDimensionLimit) {\n        if (canvas.width > $3f38c4817eb4f38b$var$canvasDimensionLimit && canvas.height > $3f38c4817eb4f38b$var$canvasDimensionLimit) {\n            if (canvas.width > canvas.height) {\n                canvas.height *= $3f38c4817eb4f38b$var$canvasDimensionLimit / canvas.width;\n                canvas.width = $3f38c4817eb4f38b$var$canvasDimensionLimit;\n            } else {\n                canvas.width *= $3f38c4817eb4f38b$var$canvasDimensionLimit / canvas.height;\n                canvas.height = $3f38c4817eb4f38b$var$canvasDimensionLimit;\n            }\n        } else if (canvas.width > $3f38c4817eb4f38b$var$canvasDimensionLimit) {\n            canvas.height *= $3f38c4817eb4f38b$var$canvasDimensionLimit / canvas.width;\n            canvas.width = $3f38c4817eb4f38b$var$canvasDimensionLimit;\n        } else {\n            canvas.width *= $3f38c4817eb4f38b$var$canvasDimensionLimit / canvas.height;\n            canvas.height = $3f38c4817eb4f38b$var$canvasDimensionLimit;\n        }\n    }\n}\nfunction $3f38c4817eb4f38b$export$403d539f215df596(canvas, options = {}) {\n    if (canvas.toBlob) return new Promise((resolve)=>{\n        canvas.toBlob(resolve, options.type ? options.type : \"image/png\", options.quality ? options.quality : 1);\n    });\n    return new Promise((resolve)=>{\n        const binaryString = window.atob(canvas.toDataURL(options.type ? options.type : undefined, options.quality ? options.quality : undefined).split(\",\")[1]);\n        const len = binaryString.length;\n        const binaryArray = new Uint8Array(len);\n        for(let i = 0; i < len; i += 1)binaryArray[i] = binaryString.charCodeAt(i);\n        resolve(new Blob([\n            binaryArray\n        ], {\n            type: options.type ? options.type : \"image/png\"\n        }));\n    });\n}\nfunction $3f38c4817eb4f38b$export$ec664d7487540b(url) {\n    return new Promise((resolve, reject)=>{\n        const img = new Image();\n        img.decode = ()=>resolve(img);\n        img.onload = ()=>resolve(img);\n        img.onerror = reject;\n        img.crossOrigin = \"anonymous\";\n        img.decoding = \"async\";\n        img.src = url;\n    });\n}\nasync function $3f38c4817eb4f38b$export$fe77aa9c02de4599(svg) {\n    return Promise.resolve().then(()=>new XMLSerializer().serializeToString(svg)).then(encodeURIComponent).then((html)=>`data:image/svg+xml;charset=utf-8,${html}`);\n}\nasync function $3f38c4817eb4f38b$export$b62810fb8ca515fa(node, width, height) {\n    const xmlns = \"http://www.w3.org/2000/svg\";\n    const svg = document.createElementNS(xmlns, \"svg\");\n    const foreignObject = document.createElementNS(xmlns, \"foreignObject\");\n    svg.setAttribute(\"width\", `${width}`);\n    svg.setAttribute(\"height\", `${height}`);\n    svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n    foreignObject.setAttribute(\"width\", \"100%\");\n    foreignObject.setAttribute(\"height\", \"100%\");\n    foreignObject.setAttribute(\"x\", \"0\");\n    foreignObject.setAttribute(\"y\", \"0\");\n    foreignObject.setAttribute(\"externalResourcesRequired\", \"true\");\n    svg.appendChild(foreignObject);\n    foreignObject.appendChild(node);\n    return $3f38c4817eb4f38b$export$fe77aa9c02de4599(svg);\n}\nconst $3f38c4817eb4f38b$export$3a92fc9ec83ef360 = (node, instance)=>{\n    if (node instanceof instance) return true;\n    const nodePrototype = Object.getPrototypeOf(node);\n    if (nodePrototype === null) return false;\n    return nodePrototype.constructor.name === instance.name || $3f38c4817eb4f38b$export$3a92fc9ec83ef360(nodePrototype, instance);\n};\n\n\nfunction $5dc335fc18f5c31c$var$formatCSSText(style) {\n    const content = style.getPropertyValue(\"content\");\n    return `${style.cssText} content: '${content.replace(/'|\"/g, \"\")}';`;\n}\nfunction $5dc335fc18f5c31c$var$formatCSSProperties(style) {\n    return (0, $3f38c4817eb4f38b$export$45b10814cc054894)(style).map((name)=>{\n        const value = style.getPropertyValue(name);\n        const priority = style.getPropertyPriority(name);\n        return `${name}: ${value}${priority ? \" !important\" : \"\"};`;\n    }).join(\" \");\n}\nfunction $5dc335fc18f5c31c$var$getPseudoElementStyle(className, pseudo, style) {\n    const selector = `.${className}:${pseudo}`;\n    const cssText = style.cssText ? $5dc335fc18f5c31c$var$formatCSSText(style) : $5dc335fc18f5c31c$var$formatCSSProperties(style);\n    return document.createTextNode(`${selector}{${cssText}}`);\n}\nfunction $5dc335fc18f5c31c$var$clonePseudoElement(nativeNode, clonedNode, pseudo) {\n    const style = window.getComputedStyle(nativeNode, pseudo);\n    const content = style.getPropertyValue(\"content\");\n    if (content === \"\" || content === \"none\") return;\n    const className = (0, $3f38c4817eb4f38b$export$31b40729666a4ae0)();\n    try {\n        clonedNode.className = `${clonedNode.className} ${className}`;\n    } catch (err) {\n        return;\n    }\n    const styleElement = document.createElement(\"style\");\n    styleElement.appendChild($5dc335fc18f5c31c$var$getPseudoElementStyle(className, pseudo, style));\n    clonedNode.appendChild(styleElement);\n}\nfunction $5dc335fc18f5c31c$export$8df63687a708ed2e(nativeNode, clonedNode) {\n    $5dc335fc18f5c31c$var$clonePseudoElement(nativeNode, clonedNode, \":before\");\n    $5dc335fc18f5c31c$var$clonePseudoElement(nativeNode, clonedNode, \":after\");\n}\n\n\n\nconst $932a96ce56c3bc50$var$WOFF = \"application/font-woff\";\nconst $932a96ce56c3bc50$var$JPEG = \"image/jpeg\";\nconst $932a96ce56c3bc50$var$mimes = {\n    woff: $932a96ce56c3bc50$var$WOFF,\n    woff2: $932a96ce56c3bc50$var$WOFF,\n    ttf: \"application/font-truetype\",\n    eot: \"application/vnd.ms-fontobject\",\n    png: \"image/png\",\n    jpg: $932a96ce56c3bc50$var$JPEG,\n    jpeg: $932a96ce56c3bc50$var$JPEG,\n    gif: \"image/gif\",\n    tiff: \"image/tiff\",\n    svg: \"image/svg+xml\",\n    webp: \"image/webp\"\n};\nfunction $932a96ce56c3bc50$var$getExtension(url) {\n    const match = /\\.([^./]*?)$/g.exec(url);\n    return match ? match[1] : \"\";\n}\nfunction $932a96ce56c3bc50$export$200548c990602f61(url) {\n    const extension = $932a96ce56c3bc50$var$getExtension(url).toLowerCase();\n    return $932a96ce56c3bc50$var$mimes[extension] || \"\";\n}\n\n\nfunction $36f8c7f53bd1328c$var$getContentFromDataUrl(dataURL) {\n    return dataURL.split(/,/)[1];\n}\nfunction $36f8c7f53bd1328c$export$f8a05efa20ffd5a(url) {\n    return url.search(/^(data:)/) !== -1;\n}\nfunction $36f8c7f53bd1328c$export$68336ea1617fa80a(content, mimeType) {\n    return `data:${mimeType};base64,${content}`;\n}\nasync function $36f8c7f53bd1328c$export$c20a8b76c95b0d41(url, init, process) {\n    const res = await fetch(url, init);\n    if (res.status === 404) throw new Error(`Resource \"${res.url}\" not found`);\n    const blob = await res.blob();\n    return new Promise((resolve, reject)=>{\n        const reader = new FileReader();\n        reader.onerror = reject;\n        reader.onloadend = ()=>{\n            try {\n                resolve(process({\n                    res: res,\n                    result: reader.result\n                }));\n            } catch (error) {\n                reject(error);\n            }\n        };\n        reader.readAsDataURL(blob);\n    });\n}\nconst $36f8c7f53bd1328c$var$cache = {};\nfunction $36f8c7f53bd1328c$var$getCacheKey(url, contentType, includeQueryParams) {\n    let key = url.replace(/\\?.*/, \"\");\n    if (includeQueryParams) key = url;\n    // font resource\n    if (/ttf|otf|eot|woff2?/i.test(key)) key = key.replace(/.*\\//, \"\");\n    return contentType ? `[${contentType}]${key}` : key;\n}\nasync function $36f8c7f53bd1328c$export$bdf0422c029b202a(resourceUrl, contentType, options) {\n    const cacheKey = $36f8c7f53bd1328c$var$getCacheKey(resourceUrl, contentType, options.includeQueryParams);\n    if ($36f8c7f53bd1328c$var$cache[cacheKey] != null) return $36f8c7f53bd1328c$var$cache[cacheKey];\n    // ref: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache\n    if (options.cacheBust) // eslint-disable-next-line no-param-reassign\n    resourceUrl += (/\\?/.test(resourceUrl) ? \"&\" : \"?\") + new Date().getTime();\n    let dataURL;\n    try {\n        const content = await $36f8c7f53bd1328c$export$c20a8b76c95b0d41(resourceUrl, options.fetchRequestInit, ({ res: res, result: result })=>{\n            if (!contentType) // eslint-disable-next-line no-param-reassign\n            contentType = res.headers.get(\"Content-Type\") || \"\";\n            return $36f8c7f53bd1328c$var$getContentFromDataUrl(result);\n        });\n        dataURL = $36f8c7f53bd1328c$export$68336ea1617fa80a(content, contentType);\n    } catch (error) {\n        dataURL = options.imagePlaceholder || \"\";\n        let msg = `Failed to fetch resource: ${resourceUrl}`;\n        if (error) msg = typeof error === \"string\" ? error : error.message;\n        if (msg) console.warn(msg);\n    }\n    $36f8c7f53bd1328c$var$cache[cacheKey] = dataURL;\n    return dataURL;\n}\n\n\nasync function $e4993691940aed80$var$cloneCanvasElement(canvas) {\n    const dataURL = canvas.toDataURL();\n    if (dataURL === \"data:,\") return canvas.cloneNode(false);\n    return (0, $3f38c4817eb4f38b$export$ec664d7487540b)(dataURL);\n}\nasync function $e4993691940aed80$var$cloneVideoElement(video, options) {\n    if (video.currentSrc) {\n        const canvas = document.createElement(\"canvas\");\n        const ctx = canvas.getContext(\"2d\");\n        canvas.width = video.clientWidth;\n        canvas.height = video.clientHeight;\n        ctx === null || ctx === void 0 || ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n        const dataURL = canvas.toDataURL();\n        return (0, $3f38c4817eb4f38b$export$ec664d7487540b)(dataURL);\n    }\n    const poster = video.poster;\n    const contentType = (0, $932a96ce56c3bc50$export$200548c990602f61)(poster);\n    const dataURL = await (0, $36f8c7f53bd1328c$export$bdf0422c029b202a)(poster, contentType, options);\n    return (0, $3f38c4817eb4f38b$export$ec664d7487540b)(dataURL);\n}\nasync function $e4993691940aed80$var$cloneIFrameElement(iframe) {\n    var _a;\n    try {\n        if ((_a = iframe === null || iframe === void 0 ? void 0 : iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.body) return await $e4993691940aed80$export$ae8e35ea29ddac22(iframe.contentDocument.body, {}, true);\n    } catch (_b) {\n    // Failed to clone iframe\n    }\n    return iframe.cloneNode(false);\n}\nasync function $e4993691940aed80$var$cloneSingleNode(node, options) {\n    if ((0, $3f38c4817eb4f38b$export$3a92fc9ec83ef360)(node, HTMLCanvasElement)) return $e4993691940aed80$var$cloneCanvasElement(node);\n    if ((0, $3f38c4817eb4f38b$export$3a92fc9ec83ef360)(node, HTMLVideoElement)) return $e4993691940aed80$var$cloneVideoElement(node, options);\n    if ((0, $3f38c4817eb4f38b$export$3a92fc9ec83ef360)(node, HTMLIFrameElement)) return $e4993691940aed80$var$cloneIFrameElement(node);\n    return node.cloneNode(false);\n}\nconst $e4993691940aed80$var$isSlotElement = (node)=>node.tagName != null && node.tagName.toUpperCase() === \"SLOT\";\nasync function $e4993691940aed80$var$cloneChildren(nativeNode, clonedNode, options) {\n    var _a, _b;\n    let children = [];\n    if ($e4993691940aed80$var$isSlotElement(nativeNode) && nativeNode.assignedNodes) children = (0, $3f38c4817eb4f38b$export$45b10814cc054894)(nativeNode.assignedNodes());\n    else if ((0, $3f38c4817eb4f38b$export$3a92fc9ec83ef360)(nativeNode, HTMLIFrameElement) && ((_a = nativeNode.contentDocument) === null || _a === void 0 ? void 0 : _a.body)) children = (0, $3f38c4817eb4f38b$export$45b10814cc054894)(nativeNode.contentDocument.body.childNodes);\n    else children = (0, $3f38c4817eb4f38b$export$45b10814cc054894)(((_b = nativeNode.shadowRoot) !== null && _b !== void 0 ? _b : nativeNode).childNodes);\n    if (children.length === 0 || (0, $3f38c4817eb4f38b$export$3a92fc9ec83ef360)(nativeNode, HTMLVideoElement)) return clonedNode;\n    await children.reduce((deferred, child)=>deferred.then(()=>$e4993691940aed80$export$ae8e35ea29ddac22(child, options)).then((clonedChild)=>{\n            if (clonedChild) clonedNode.appendChild(clonedChild);\n        }), Promise.resolve());\n    return clonedNode;\n}\nfunction $e4993691940aed80$var$cloneCSSStyle(nativeNode, clonedNode) {\n    const targetStyle = clonedNode.style;\n    if (!targetStyle) return;\n    const sourceStyle = window.getComputedStyle(nativeNode);\n    if (sourceStyle.cssText) {\n        targetStyle.cssText = sourceStyle.cssText;\n        targetStyle.transformOrigin = sourceStyle.transformOrigin;\n    } else (0, $3f38c4817eb4f38b$export$45b10814cc054894)(sourceStyle).forEach((name)=>{\n        let value = sourceStyle.getPropertyValue(name);\n        if (name === \"font-size\" && value.endsWith(\"px\")) {\n            const reducedFont = Math.floor(parseFloat(value.substring(0, value.length - 2))) - 0.1;\n            value = `${reducedFont}px`;\n        }\n        if ((0, $3f38c4817eb4f38b$export$3a92fc9ec83ef360)(nativeNode, HTMLIFrameElement) && name === \"display\" && value === \"inline\") value = \"block\";\n        if (name === \"d\" && clonedNode.getAttribute(\"d\")) value = `path(${clonedNode.getAttribute(\"d\")})`;\n        targetStyle.setProperty(name, value, sourceStyle.getPropertyPriority(name));\n    });\n}\nfunction $e4993691940aed80$var$cloneInputValue(nativeNode, clonedNode) {\n    if ((0, $3f38c4817eb4f38b$export$3a92fc9ec83ef360)(nativeNode, HTMLTextAreaElement)) clonedNode.innerHTML = nativeNode.value;\n    if ((0, $3f38c4817eb4f38b$export$3a92fc9ec83ef360)(nativeNode, HTMLInputElement)) clonedNode.setAttribute(\"value\", nativeNode.value);\n}\nfunction $e4993691940aed80$var$cloneSelectValue(nativeNode, clonedNode) {\n    if ((0, $3f38c4817eb4f38b$export$3a92fc9ec83ef360)(nativeNode, HTMLSelectElement)) {\n        const clonedSelect = clonedNode;\n        const selectedOption = Array.from(clonedSelect.children).find((child)=>nativeNode.value === child.getAttribute(\"value\"));\n        if (selectedOption) selectedOption.setAttribute(\"selected\", \"\");\n    }\n}\nfunction $e4993691940aed80$var$decorate(nativeNode, clonedNode) {\n    if ((0, $3f38c4817eb4f38b$export$3a92fc9ec83ef360)(clonedNode, Element)) {\n        $e4993691940aed80$var$cloneCSSStyle(nativeNode, clonedNode);\n        (0, $5dc335fc18f5c31c$export$8df63687a708ed2e)(nativeNode, clonedNode);\n        $e4993691940aed80$var$cloneInputValue(nativeNode, clonedNode);\n        $e4993691940aed80$var$cloneSelectValue(nativeNode, clonedNode);\n    }\n    return clonedNode;\n}\nasync function $e4993691940aed80$var$ensureSVGSymbols(clone, options) {\n    const uses = clone.querySelectorAll ? clone.querySelectorAll(\"use\") : [];\n    if (uses.length === 0) return clone;\n    const processedDefs = {};\n    for(let i = 0; i < uses.length; i++){\n        const use = uses[i];\n        const id = use.getAttribute(\"xlink:href\");\n        if (id) {\n            const exist = clone.querySelector(id);\n            const definition = document.querySelector(id);\n            if (!exist && definition && !processedDefs[id]) // eslint-disable-next-line no-await-in-loop\n            processedDefs[id] = await $e4993691940aed80$export$ae8e35ea29ddac22(definition, options, true);\n        }\n    }\n    const nodes = Object.values(processedDefs);\n    if (nodes.length) {\n        const ns = \"http://www.w3.org/1999/xhtml\";\n        const svg = document.createElementNS(ns, \"svg\");\n        svg.setAttribute(\"xmlns\", ns);\n        svg.style.position = \"absolute\";\n        svg.style.width = \"0\";\n        svg.style.height = \"0\";\n        svg.style.overflow = \"hidden\";\n        svg.style.display = \"none\";\n        const defs = document.createElementNS(ns, \"defs\");\n        svg.appendChild(defs);\n        for(let i = 0; i < nodes.length; i++)defs.appendChild(nodes[i]);\n        clone.appendChild(svg);\n    }\n    return clone;\n}\nasync function $e4993691940aed80$export$ae8e35ea29ddac22(node, options, isRoot) {\n    if (!isRoot && options.filter && !options.filter(node)) return null;\n    return Promise.resolve(node).then((clonedNode)=>$e4993691940aed80$var$cloneSingleNode(clonedNode, options)).then((clonedNode)=>$e4993691940aed80$var$cloneChildren(node, clonedNode, options)).then((clonedNode)=>$e4993691940aed80$var$decorate(node, clonedNode)).then((clonedNode)=>$e4993691940aed80$var$ensureSVGSymbols(clonedNode, options));\n}\n\n\n\n\n\nconst $6f23389cdbe0dece$var$URL_REGEX = /url\\((['\"]?)([^'\"]+?)\\1\\)/g;\nconst $6f23389cdbe0dece$var$URL_WITH_FORMAT_REGEX = /url\\([^)]+\\)\\s*format\\(([\"']?)([^\"']+)\\1\\)/g;\nconst $6f23389cdbe0dece$var$FONT_SRC_REGEX = /src:\\s*(?:url\\([^)]+\\)\\s*format\\([^)]+\\)[,;]\\s*)+/g;\nfunction $6f23389cdbe0dece$var$toRegex(url) {\n    // eslint-disable-next-line no-useless-escape\n    const escaped = url.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, \"\\\\$1\");\n    return new RegExp(`(url\\\\(['\"]?)(${escaped})(['\"]?\\\\))`, \"g\");\n}\nfunction $6f23389cdbe0dece$export$d04549d631b8762d(cssText) {\n    const urls = [];\n    cssText.replace($6f23389cdbe0dece$var$URL_REGEX, (raw, quotation, url)=>{\n        urls.push(url);\n        return raw;\n    });\n    return urls.filter((url)=>!(0, $36f8c7f53bd1328c$export$f8a05efa20ffd5a)(url));\n}\nasync function $6f23389cdbe0dece$export$2be46bb7e96db87f(cssText, resourceURL, baseURL, options, getContentFromUrl) {\n    try {\n        const resolvedURL = baseURL ? (0, $3f38c4817eb4f38b$export$f85c16a6d62f7d63)(resourceURL, baseURL) : resourceURL;\n        const contentType = (0, $932a96ce56c3bc50$export$200548c990602f61)(resourceURL);\n        let dataURL;\n        if (getContentFromUrl) {\n            const content = await getContentFromUrl(resolvedURL);\n            dataURL = (0, $36f8c7f53bd1328c$export$68336ea1617fa80a)(content, contentType);\n        } else dataURL = await (0, $36f8c7f53bd1328c$export$bdf0422c029b202a)(resolvedURL, contentType, options);\n        return cssText.replace($6f23389cdbe0dece$var$toRegex(resourceURL), `$1${dataURL}$3`);\n    } catch (error) {\n    // pass\n    }\n    return cssText;\n}\nfunction $6f23389cdbe0dece$var$filterPreferredFontFormat(str, { preferredFontFormat: preferredFontFormat }) {\n    return !preferredFontFormat ? str : str.replace($6f23389cdbe0dece$var$FONT_SRC_REGEX, (match)=>{\n        // eslint-disable-next-line no-constant-condition\n        while(true){\n            const [src, , format] = $6f23389cdbe0dece$var$URL_WITH_FORMAT_REGEX.exec(match) || [];\n            if (!format) return \"\";\n            if (format === preferredFontFormat) return `src: ${src};`;\n        }\n    });\n}\nfunction $6f23389cdbe0dece$export$7b668369e5eab853(url) {\n    return url.search($6f23389cdbe0dece$var$URL_REGEX) !== -1;\n}\nasync function $6f23389cdbe0dece$export$3d88803585cbbc21(cssText, baseUrl, options) {\n    if (!$6f23389cdbe0dece$export$7b668369e5eab853(cssText)) return cssText;\n    const filteredCSSText = $6f23389cdbe0dece$var$filterPreferredFontFormat(cssText, options);\n    const urls = $6f23389cdbe0dece$export$d04549d631b8762d(filteredCSSText);\n    return urls.reduce((deferred, url)=>deferred.then((css)=>$6f23389cdbe0dece$export$2be46bb7e96db87f(css, url, baseUrl, options)), Promise.resolve(filteredCSSText));\n}\n\n\n\n\n\nasync function $d00e8710aa74d8f2$var$embedProp(propName, node, options) {\n    var _a;\n    const propValue = (_a = node.style) === null || _a === void 0 ? void 0 : _a.getPropertyValue(propName);\n    if (propValue) {\n        const cssString = await (0, $6f23389cdbe0dece$export$3d88803585cbbc21)(propValue, null, options);\n        node.style.setProperty(propName, cssString, node.style.getPropertyPriority(propName));\n        return true;\n    }\n    return false;\n}\nasync function $d00e8710aa74d8f2$var$embedBackground(clonedNode, options) {\n    if (!await $d00e8710aa74d8f2$var$embedProp(\"background\", clonedNode, options)) await $d00e8710aa74d8f2$var$embedProp(\"background-image\", clonedNode, options);\n    if (!await $d00e8710aa74d8f2$var$embedProp(\"mask\", clonedNode, options)) await $d00e8710aa74d8f2$var$embedProp(\"mask-image\", clonedNode, options);\n}\nasync function $d00e8710aa74d8f2$var$embedImageNode(clonedNode, options) {\n    const isImageElement = (0, $3f38c4817eb4f38b$export$3a92fc9ec83ef360)(clonedNode, HTMLImageElement);\n    if (!(isImageElement && !(0, $36f8c7f53bd1328c$export$f8a05efa20ffd5a)(clonedNode.src)) && !((0, $3f38c4817eb4f38b$export$3a92fc9ec83ef360)(clonedNode, SVGImageElement) && !(0, $36f8c7f53bd1328c$export$f8a05efa20ffd5a)(clonedNode.href.baseVal))) return;\n    const url = isImageElement ? clonedNode.src : clonedNode.href.baseVal;\n    const dataURL = await (0, $36f8c7f53bd1328c$export$bdf0422c029b202a)(url, (0, $932a96ce56c3bc50$export$200548c990602f61)(url), options);\n    await new Promise((resolve, reject)=>{\n        clonedNode.onload = resolve;\n        clonedNode.onerror = reject;\n        const image = clonedNode;\n        if (image.decode) image.decode = resolve;\n        if (image.loading === \"lazy\") image.loading = \"eager\";\n        if (isImageElement) {\n            clonedNode.srcset = \"\";\n            clonedNode.src = dataURL;\n        } else clonedNode.href.baseVal = dataURL;\n    });\n}\nasync function $d00e8710aa74d8f2$var$embedChildren(clonedNode, options) {\n    const children = (0, $3f38c4817eb4f38b$export$45b10814cc054894)(clonedNode.childNodes);\n    const deferreds = children.map((child)=>$d00e8710aa74d8f2$export$6660fa8dd20e53aa(child, options));\n    await Promise.all(deferreds).then(()=>clonedNode);\n}\nasync function $d00e8710aa74d8f2$export$6660fa8dd20e53aa(clonedNode, options) {\n    if ((0, $3f38c4817eb4f38b$export$3a92fc9ec83ef360)(clonedNode, Element)) {\n        await $d00e8710aa74d8f2$var$embedBackground(clonedNode, options);\n        await $d00e8710aa74d8f2$var$embedImageNode(clonedNode, options);\n        await $d00e8710aa74d8f2$var$embedChildren(clonedNode, options);\n    }\n}\n\n\nfunction $9466082ff3ed5bc2$export$d63a6b7859608045(node, options) {\n    const { style: style } = node;\n    if (options.backgroundColor) style.backgroundColor = options.backgroundColor;\n    if (options.width) style.width = `${options.width}px`;\n    if (options.height) style.height = `${options.height}px`;\n    const manual = options.style;\n    if (manual != null) Object.keys(manual).forEach((key)=>{\n        style[key] = manual[key];\n    });\n    return node;\n}\n\n\n\n\n\nconst $e00ffe9f0e6cf773$var$cssFetchCache = {};\nasync function $e00ffe9f0e6cf773$var$fetchCSS(url) {\n    let cache = $e00ffe9f0e6cf773$var$cssFetchCache[url];\n    if (cache != null) return cache;\n    const res = await fetch(url);\n    const cssText = await res.text();\n    cache = {\n        url: url,\n        cssText: cssText\n    };\n    $e00ffe9f0e6cf773$var$cssFetchCache[url] = cache;\n    return cache;\n}\nasync function $e00ffe9f0e6cf773$var$embedFonts(data, options) {\n    let cssText = data.cssText;\n    const regexUrl = /url\\([\"']?([^\"')]+)[\"']?\\)/g;\n    const fontLocs = cssText.match(/url\\([^)]+\\)/g) || [];\n    const loadFonts = fontLocs.map(async (loc)=>{\n        let url = loc.replace(regexUrl, \"$1\");\n        if (!url.startsWith(\"https://\")) url = new URL(url, data.url).href;\n        return (0, $36f8c7f53bd1328c$export$c20a8b76c95b0d41)(url, options.fetchRequestInit, ({ result: result })=>{\n            cssText = cssText.replace(loc, `url(${result})`);\n            return [\n                loc,\n                result\n            ];\n        });\n    });\n    return Promise.all(loadFonts).then(()=>cssText);\n}\nfunction $e00ffe9f0e6cf773$var$parseCSS(source) {\n    if (source == null) return [];\n    const result = [];\n    const commentsRegex = /(\\/\\*[\\s\\S]*?\\*\\/)/gi;\n    // strip out comments\n    let cssText = source.replace(commentsRegex, \"\");\n    // eslint-disable-next-line prefer-regex-literals\n    const keyframesRegex = new RegExp(\"((@.*?keyframes [\\\\s\\\\S]*?){([\\\\s\\\\S]*?}\\\\s*?)})\", \"gi\");\n    // eslint-disable-next-line no-constant-condition\n    while(true){\n        const matches = keyframesRegex.exec(cssText);\n        if (matches === null) break;\n        result.push(matches[0]);\n    }\n    cssText = cssText.replace(keyframesRegex, \"\");\n    const importRegex = /@import[\\s\\S]*?url\\([^)]*\\)[\\s\\S]*?;/gi;\n    // to match css & media queries together\n    const combinedCSSRegex = \"((\\\\s*?(?:\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/)?\\\\s*?@media[\\\\s\\\\S]*?){([\\\\s\\\\S]*?)}\\\\s*?})|(([\\\\s\\\\S]*?){([\\\\s\\\\S]*?)})\";\n    // unified regex\n    const unifiedRegex = new RegExp(combinedCSSRegex, \"gi\");\n    // eslint-disable-next-line no-constant-condition\n    while(true){\n        let matches = importRegex.exec(cssText);\n        if (matches === null) {\n            matches = unifiedRegex.exec(cssText);\n            if (matches === null) break;\n            else importRegex.lastIndex = unifiedRegex.lastIndex;\n        } else unifiedRegex.lastIndex = importRegex.lastIndex;\n        result.push(matches[0]);\n    }\n    return result;\n}\nasync function $e00ffe9f0e6cf773$var$getCSSRules(styleSheets, options) {\n    const ret = [];\n    const deferreds = [];\n    // First loop inlines imports\n    styleSheets.forEach((sheet)=>{\n        if (\"cssRules\" in sheet) try {\n            (0, $3f38c4817eb4f38b$export$45b10814cc054894)(sheet.cssRules || []).forEach((item, index)=>{\n                if (item.type === CSSRule.IMPORT_RULE) {\n                    let importIndex = index + 1;\n                    const url = item.href;\n                    const deferred = $e00ffe9f0e6cf773$var$fetchCSS(url).then((metadata)=>$e00ffe9f0e6cf773$var$embedFonts(metadata, options)).then((cssText)=>$e00ffe9f0e6cf773$var$parseCSS(cssText).forEach((rule)=>{\n                            try {\n                                sheet.insertRule(rule, rule.startsWith(\"@import\") ? importIndex += 1 : sheet.cssRules.length);\n                            } catch (error) {\n                                console.error(\"Error inserting rule from remote css\", {\n                                    rule: rule,\n                                    error: error\n                                });\n                            }\n                        })).catch((e)=>{\n                        console.error(\"Error loading remote css\", e.toString());\n                    });\n                    deferreds.push(deferred);\n                }\n            });\n        } catch (e) {\n            const inline = styleSheets.find((a)=>a.href == null) || document.styleSheets[0];\n            if (sheet.href != null) deferreds.push($e00ffe9f0e6cf773$var$fetchCSS(sheet.href).then((metadata)=>$e00ffe9f0e6cf773$var$embedFonts(metadata, options)).then((cssText)=>$e00ffe9f0e6cf773$var$parseCSS(cssText).forEach((rule)=>{\n                    inline.insertRule(rule, sheet.cssRules.length);\n                })).catch((err)=>{\n                console.error(\"Error loading remote stylesheet\", err);\n            }));\n            console.error(\"Error inlining remote css file\", e);\n        }\n    });\n    return Promise.all(deferreds).then(()=>{\n        // Second loop parses rules\n        styleSheets.forEach((sheet)=>{\n            if (\"cssRules\" in sheet) try {\n                (0, $3f38c4817eb4f38b$export$45b10814cc054894)(sheet.cssRules || []).forEach((item)=>{\n                    ret.push(item);\n                });\n            } catch (e) {\n                console.error(`Error while reading CSS rules from ${sheet.href}`, e);\n            }\n        });\n        return ret;\n    });\n}\nfunction $e00ffe9f0e6cf773$var$getWebFontRules(cssRules) {\n    return cssRules.filter((rule)=>rule.type === CSSRule.FONT_FACE_RULE).filter((rule)=>(0, $6f23389cdbe0dece$export$7b668369e5eab853)(rule.style.getPropertyValue(\"src\")));\n}\nasync function $e00ffe9f0e6cf773$var$parseWebFontRules(node, options) {\n    if (node.ownerDocument == null) throw new Error(\"Provided element is not within a Document\");\n    const styleSheets = (0, $3f38c4817eb4f38b$export$45b10814cc054894)(node.ownerDocument.styleSheets);\n    const cssRules = await $e00ffe9f0e6cf773$var$getCSSRules(styleSheets, options);\n    return $e00ffe9f0e6cf773$var$getWebFontRules(cssRules);\n}\nasync function $e00ffe9f0e6cf773$export$253c9aa3d83a57b6(node, options) {\n    const rules = await $e00ffe9f0e6cf773$var$parseWebFontRules(node, options);\n    const cssTexts = await Promise.all(rules.map((rule)=>{\n        const baseUrl = rule.parentStyleSheet ? rule.parentStyleSheet.href : null;\n        return (0, $6f23389cdbe0dece$export$3d88803585cbbc21)(rule.cssText, baseUrl, options);\n    }));\n    return cssTexts.join(\"\\n\");\n}\nasync function $e00ffe9f0e6cf773$export$2c2c83b77c8cb421(clonedNode, options) {\n    const cssText = options.fontEmbedCSS != null ? options.fontEmbedCSS : options.skipFonts ? null : await $e00ffe9f0e6cf773$export$253c9aa3d83a57b6(clonedNode, options);\n    if (cssText) {\n        const styleNode = document.createElement(\"style\");\n        const sytleContent = document.createTextNode(cssText);\n        styleNode.appendChild(sytleContent);\n        if (clonedNode.firstChild) clonedNode.insertBefore(styleNode, clonedNode.firstChild);\n        else clonedNode.appendChild(styleNode);\n    }\n}\n\n\n\nasync function $49e912db89b35827$export$20d300cb2d558b7(node, options = {}) {\n    const { width: width, height: height } = (0, $3f38c4817eb4f38b$export$ada5537b2c061996)(node, options);\n    const clonedNode = await (0, $e4993691940aed80$export$ae8e35ea29ddac22)(node, options, true);\n    await (0, $e00ffe9f0e6cf773$export$2c2c83b77c8cb421)(clonedNode, options);\n    await (0, $d00e8710aa74d8f2$export$6660fa8dd20e53aa)(clonedNode, options);\n    (0, $9466082ff3ed5bc2$export$d63a6b7859608045)(clonedNode, options);\n    const datauri = await (0, $3f38c4817eb4f38b$export$b62810fb8ca515fa)(clonedNode, width, height);\n    return datauri;\n}\nasync function $49e912db89b35827$export$f87f6982d1fd4f81(node, options = {}) {\n    const { width: width, height: height } = (0, $3f38c4817eb4f38b$export$ada5537b2c061996)(node, options);\n    const svg = await $49e912db89b35827$export$20d300cb2d558b7(node, options);\n    const img = await (0, $3f38c4817eb4f38b$export$ec664d7487540b)(svg);\n    const canvas = document.createElement(\"canvas\");\n    const context = canvas.getContext(\"2d\");\n    const ratio = options.pixelRatio || (0, $3f38c4817eb4f38b$export$d39ce20a37bba061)();\n    const canvasWidth = options.canvasWidth || width;\n    const canvasHeight = options.canvasHeight || height;\n    canvas.width = canvasWidth * ratio;\n    canvas.height = canvasHeight * ratio;\n    if (!options.skipAutoScale) (0, $3f38c4817eb4f38b$export$c2c809a2fe6b0f1a)(canvas);\n    canvas.style.width = `${canvasWidth}`;\n    canvas.style.height = `${canvasHeight}`;\n    if (options.backgroundColor) {\n        context.fillStyle = options.backgroundColor;\n        context.fillRect(0, 0, canvas.width, canvas.height);\n    }\n    context.drawImage(img, 0, 0, canvas.width, canvas.height);\n    return canvas;\n}\nasync function $49e912db89b35827$export$6f9e32581c0cde11(node, options = {}) {\n    const { width: width, height: height } = (0, $3f38c4817eb4f38b$export$ada5537b2c061996)(node, options);\n    const canvas = await $49e912db89b35827$export$f87f6982d1fd4f81(node, options);\n    const ctx = canvas.getContext(\"2d\");\n    return ctx.getImageData(0, 0, width, height).data;\n}\nasync function $49e912db89b35827$export$aba256f33615c92e(node, options = {}) {\n    const canvas = await $49e912db89b35827$export$f87f6982d1fd4f81(node, options);\n    return canvas.toDataURL();\n}\nasync function $49e912db89b35827$export$ed218bd2440d33a5(node, options = {}) {\n    const canvas = await $49e912db89b35827$export$f87f6982d1fd4f81(node, options);\n    return canvas.toDataURL(\"image/jpeg\", options.quality || 1);\n}\nasync function $49e912db89b35827$export$b20f4ee19ffa0668(node, options = {}) {\n    const canvas = await $49e912db89b35827$export$f87f6982d1fd4f81(node, options);\n    const blob = await (0, $3f38c4817eb4f38b$export$403d539f215df596)(canvas);\n    return blob;\n}\nasync function $49e912db89b35827$export$92678bad7eef403b(node, options = {}) {\n    return (0, $e00ffe9f0e6cf773$export$253c9aa3d83a57b6)(node, options);\n}\n\n\n\n\nconst $048c0dc54e08960c$export$4778991634f78fa5 = ()=>{\n    (0, $c498bb1c05d876ef$export$3c628e933563550d)(\"ÁîüÊàêÊà™Âõæ‰∏≠ÔºåËØ∑Âú®Âè≥‰æßÊü•Áúã\");\n    const element = window[\"DOM_SHOT_EXT_DOM\"] || null;\n    if (!element) return;\n    (0, $49e912db89b35827$export$aba256f33615c92e)(element, {\n        backgroundColor: \"transparent\"\n    }).then((imgData)=>{\n        window.postMessage({\n            source: (0, $b6370854aea1ab9c$export$14333815d08d1368),\n            action: (0, $b6370854aea1ab9c$export$87e24ddbab2613d9).domShot,\n            payload: imgData\n        }, \"*\");\n    }).catch(console.error);\n};\n\n\nclass $24add57b2feb7361$var$Helper {\n    constructor(tabId){\n        this.clearEvent = ()=>{};\n        this.init = async ()=>{\n            this.clearEvent();\n            this.initUtils();\n        };\n        (0, $c498bb1c05d876ef$export$a2b6a13999826ac7)();\n        this.tabId = tabId || 0;\n    }\n    initUtils() {\n        const messageHandler = async (event)=>{\n            console.log(\"[dodo] \", \"event\", event);\n            if (event?.data?.source !== (0, $b6370854aea1ab9c$export$14333815d08d1368)) return;\n            const { action: action } = event.data || {};\n            this.utilsActionMap[action]?.();\n        };\n        this.clearEvent = ()=>{\n            window.removeEventListener(\"message\", messageHandler);\n            window.removeEventListener(\"beforeunload\", this.clearEvent);\n        };\n        window.addEventListener(\"message\", messageHandler);\n        window.addEventListener(\"beforeunload\", this.clearEvent);\n    }\n    get utilsActionMap() {\n        return {\n            /** Áªô DOM Êà™ÂõæÔºå‰øùÁïôÈÄèÊòéËâ≤ */ [(0, $b6370854aea1ab9c$export$87e24ddbab2613d9).domShot]: (0, $048c0dc54e08960c$export$4778991634f78fa5)\n        };\n    }\n}\nconst $24add57b2feb7361$var$DOM_SHOT_HELPER_KEY = \"dom_shot_ext_helper\";\nif (window[$24add57b2feb7361$var$DOM_SHOT_HELPER_KEY]) window[$24add57b2feb7361$var$DOM_SHOT_HELPER_KEY].init();\nelse {\n    const helper = new $24add57b2feb7361$var$Helper(...window[0, $b6370854aea1ab9c$export$14333815d08d1368]?.args || []);\n    window[$24add57b2feb7361$var$DOM_SHOT_HELPER_KEY] = helper;\n    helper.init();\n}\n\n})();\n//# sourceMappingURL=helper.js.map\n","import { DOM_SHOT_EXT_ACTION, DOM_SHOT_EXT_NAME } from \"./utils/constant\";\nimport { domShotVersion } from \"./utils\";\nimport { shotDom } from \"./utils/dom\";\n\nclass Helper {\n  tabId: number;\n  constructor (tabId?: number) {\n    domShotVersion();\n    this.tabId = tabId || 0;\n  }\n\n  clearEvent = () => { };\n\n  init = async () => {\n    this.clearEvent();\n    this.initUtils();\n  };\n\n  initUtils () {\n    const messageHandler = async (event: MessageEvent<any>) => {\n      console.log('[dodo] ', 'event', event);\n      if (event?.data?.source !== DOM_SHOT_EXT_NAME) return;\n\n      const { action } = event.data || {};\n\n      this.utilsActionMap[action]?.();\n    };\n\n    this.clearEvent = () => {\n      window.removeEventListener('message', messageHandler);\n      window.removeEventListener('beforeunload', this.clearEvent);\n    };\n\n    window.addEventListener('message', messageHandler);\n    window.addEventListener('beforeunload', this.clearEvent);\n  }\n\n  get utilsActionMap () {\n    return {\n      /** Áªô DOM Êà™ÂõæÔºå‰øùÁïôÈÄèÊòéËâ≤ */\n      [DOM_SHOT_EXT_ACTION.domShot]: shotDom,\n    };\n  }\n}\n\nconst DOM_SHOT_HELPER_KEY = 'dom_shot_ext_helper';\nif (window[DOM_SHOT_HELPER_KEY]) {\n  window[DOM_SHOT_HELPER_KEY].init();\n} else {\n  const helper = new Helper(...(window[DOM_SHOT_EXT_NAME]?.args || []));\n  window[DOM_SHOT_HELPER_KEY] = helper;\n  helper.init();\n}\n","export const DOM_SHOT_EXT_NAME = 'dom_shot_chrome_extension';\n\nexport enum DOM_SHOT_EXT_ACTION {\n  ready,\n  domShot,\n};\n","import { DOM_SHOT_EXT_ACTION, DOM_SHOT_EXT_NAME } from \"./constant\";\nimport { version, buildTime } from '../../package.json'\n\nexport const isDev = () => {\n  return process.env.NODE_ENV === 'development'\n};\n\nexport const waitTime = async (timeout = 0) => {\n  return new Promise(resolve => setTimeout(() => resolve(true), timeout))\n}\n\nexport const doDomShotAction = (action: DOM_SHOT_EXT_ACTION, payload?: any) => {\n  window.postMessage({ source: DOM_SHOT_EXT_NAME, action, payload }, '*');\n}\n\nexport const domShotLog = (message?: any, ...optionalParams: any[]) => {\n  console.log('[üî∏DOM_SHOTüî∏]', message, ...optionalParams)\n}\n\nexport const domShotError = (message?: any, ...optionalParams: any[]) => {\n  console.error('[üî∏DOM_SHOTüî∏]', message, ...optionalParams)\n}\n\nexport const domShotVersion = () => {\n  console.log(`[üî∏DOM_SHOTüî∏] Êèí‰ª∂ÁâàÊú¨%c v${version} at ${buildTime}`, 'color: orange;')\n}\n","{\n  \"name\": \"dom-shot-chrome-extension\",\n  \"version\": \"2.2.7\",\n  \"buildTime\": \"2024-07-26\",\n  \"source\": \"src/index.html\",\n  \"description\": \"dom-shot-chrome-extension\",\n  \"dependencies\": {\n    \"clsx\": \"^1.2.1\",\n    \"dayjs\": \"^1.11.7\",\n    \"html-to-image\": \"^1.11.11\",\n    \"mobx\": \"^6.12.3\",\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\",\n    \"react-draggable\": \"^4.4.6\",\n    \"react-select\": \"^5.7.7\"\n  },\n  \"devDependencies\": {\n    \"@parcel/transformer-less\": \"^2.9.3\",\n    \"@types/node\": \"^20.6.5\",\n    \"@types/react\": \"18.0\",\n    \"@types/react-dom\": \"18.0\",\n    \"chrome-types\": \"^0.1.231\",\n    \"html2canvas\": \"^1.4.1\",\n    \"parcel\": \"^2.8.3\",\n    \"postcss\": \"^8.4.30\",\n    \"postcss-modules\": \"^4.3.1\",\n    \"process\": \"^0.11.10\"\n  },\n  \"scripts\": {\n    \"start\": \"parcel src/index.tsx src/popup.html  --no-cache\",\n    \"start:bg\": \"parcel build src/background.ts --no-cache\",\n    \"build\": \"rm -rf dist/; parcel build src/background.ts src/helper.ts src/index.tsx src/devtools.html src/sidebar.html --no-content-hash --no-cache;sh deploy.sh\",\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://gitlab.temu.team/dawn.tang/dom-shot-chrome-extension.git\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://gitlab.temu.team/dawn.tang/dom-shot-chrome-extension/-/issues\"\n  },\n  \"homepage\": \"https://gitlab.temu.team/dawn.tang/dom-shot-chrome-extension\"\n}\n","import { toPng } from 'html-to-image';\nimport { DOM_SHOT_EXT_ACTION, DOM_SHOT_EXT_NAME } from './constant';\nimport { domShotLog } from '.';\n\n/** Áªô DOM Êà™ÂõæÔºå‰øùÁïôÈÄèÊòéËâ≤ */\nexport const shotDom = () => {\n  domShotLog('ÁîüÊàêÊà™Âõæ‰∏≠ÔºåËØ∑Âú®Âè≥‰æßÊü•Áúã');\n  const element = window['DOM_SHOT_EXT_DOM'] || null;\n\n  if (!element) return;\n\n  toPng(element, {\n    backgroundColor: 'transparent'\n  }).then(imgData => {\n    window.postMessage({\n      source: DOM_SHOT_EXT_NAME,\n      action: DOM_SHOT_EXT_ACTION.domShot,\n      payload: imgData\n    }, '*');\n  }).catch(console.error);\n};","import { cloneNode } from './clone-node';\nimport { embedImages } from './embed-images';\nimport { applyStyle } from './apply-style';\nimport { embedWebFonts, getWebFontCSS } from './embed-webfonts';\nimport { getImageSize, getPixelRatio, createImage, canvasToBlob, nodeToDataURL, checkCanvasDimensions, } from './util';\nexport async function toSvg(node, options = {}) {\n    const { width, height } = getImageSize(node, options);\n    const clonedNode = (await cloneNode(node, options, true));\n    await embedWebFonts(clonedNode, options);\n    await embedImages(clonedNode, options);\n    applyStyle(clonedNode, options);\n    const datauri = await nodeToDataURL(clonedNode, width, height);\n    return datauri;\n}\nexport async function toCanvas(node, options = {}) {\n    const { width, height } = getImageSize(node, options);\n    const svg = await toSvg(node, options);\n    const img = await createImage(svg);\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n    const ratio = options.pixelRatio || getPixelRatio();\n    const canvasWidth = options.canvasWidth || width;\n    const canvasHeight = options.canvasHeight || height;\n    canvas.width = canvasWidth * ratio;\n    canvas.height = canvasHeight * ratio;\n    if (!options.skipAutoScale) {\n        checkCanvasDimensions(canvas);\n    }\n    canvas.style.width = `${canvasWidth}`;\n    canvas.style.height = `${canvasHeight}`;\n    if (options.backgroundColor) {\n        context.fillStyle = options.backgroundColor;\n        context.fillRect(0, 0, canvas.width, canvas.height);\n    }\n    context.drawImage(img, 0, 0, canvas.width, canvas.height);\n    return canvas;\n}\nexport async function toPixelData(node, options = {}) {\n    const { width, height } = getImageSize(node, options);\n    const canvas = await toCanvas(node, options);\n    const ctx = canvas.getContext('2d');\n    return ctx.getImageData(0, 0, width, height).data;\n}\nexport async function toPng(node, options = {}) {\n    const canvas = await toCanvas(node, options);\n    return canvas.toDataURL();\n}\nexport async function toJpeg(node, options = {}) {\n    const canvas = await toCanvas(node, options);\n    return canvas.toDataURL('image/jpeg', options.quality || 1);\n}\nexport async function toBlob(node, options = {}) {\n    const canvas = await toCanvas(node, options);\n    const blob = await canvasToBlob(canvas);\n    return blob;\n}\nexport async function getFontEmbedCSS(node, options = {}) {\n    return getWebFontCSS(node, options);\n}\n//# sourceMappingURL=index.js.map","import { Options } from './types'\nimport { cloneNode } from './clone-node'\nimport { embedImages } from './embed-images'\nimport { applyStyle } from './apply-style'\nimport { embedWebFonts, getWebFontCSS } from './embed-webfonts'\nimport {\n  getImageSize,\n  getPixelRatio,\n  createImage,\n  canvasToBlob,\n  nodeToDataURL,\n  checkCanvasDimensions,\n} from './util'\n\nexport async function toSvg<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<string> {\n  const { width, height } = getImageSize(node, options)\n  const clonedNode = (await cloneNode(node, options, true)) as HTMLElement\n  await embedWebFonts(clonedNode, options)\n  await embedImages(clonedNode, options)\n  applyStyle(clonedNode, options)\n  const datauri = await nodeToDataURL(clonedNode, width, height)\n  return datauri\n}\n\nexport async function toCanvas<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<HTMLCanvasElement> {\n  const { width, height } = getImageSize(node, options)\n  const svg = await toSvg(node, options)\n  const img = await createImage(svg)\n\n  const canvas = document.createElement('canvas')\n  const context = canvas.getContext('2d')!\n  const ratio = options.pixelRatio || getPixelRatio()\n  const canvasWidth = options.canvasWidth || width\n  const canvasHeight = options.canvasHeight || height\n\n  canvas.width = canvasWidth * ratio\n  canvas.height = canvasHeight * ratio\n\n  if (!options.skipAutoScale) {\n    checkCanvasDimensions(canvas)\n  }\n  canvas.style.width = `${canvasWidth}`\n  canvas.style.height = `${canvasHeight}`\n\n  if (options.backgroundColor) {\n    context.fillStyle = options.backgroundColor\n    context.fillRect(0, 0, canvas.width, canvas.height)\n  }\n\n  context.drawImage(img, 0, 0, canvas.width, canvas.height)\n\n  return canvas\n}\n\nexport async function toPixelData<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<Uint8ClampedArray> {\n  const { width, height } = getImageSize(node, options)\n  const canvas = await toCanvas(node, options)\n  const ctx = canvas.getContext('2d')!\n  return ctx.getImageData(0, 0, width, height).data\n}\n\nexport async function toPng<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<string> {\n  const canvas = await toCanvas(node, options)\n  return canvas.toDataURL()\n}\n\nexport async function toJpeg<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<string> {\n  const canvas = await toCanvas(node, options)\n  return canvas.toDataURL('image/jpeg', options.quality || 1)\n}\n\nexport async function toBlob<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<Blob | null> {\n  const canvas = await toCanvas(node, options)\n  const blob = await canvasToBlob(canvas)\n  return blob\n}\n\nexport async function getFontEmbedCSS<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<string> {\n  return getWebFontCSS(node, options)\n}\n","import { clonePseudoElements } from './clone-pseudos';\nimport { createImage, toArray, isInstanceOfElement } from './util';\nimport { getMimeType } from './mimes';\nimport { resourceToDataURL } from './dataurl';\nasync function cloneCanvasElement(canvas) {\n    const dataURL = canvas.toDataURL();\n    if (dataURL === 'data:,') {\n        return canvas.cloneNode(false);\n    }\n    return createImage(dataURL);\n}\nasync function cloneVideoElement(video, options) {\n    if (video.currentSrc) {\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        canvas.width = video.clientWidth;\n        canvas.height = video.clientHeight;\n        ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n        const dataURL = canvas.toDataURL();\n        return createImage(dataURL);\n    }\n    const poster = video.poster;\n    const contentType = getMimeType(poster);\n    const dataURL = await resourceToDataURL(poster, contentType, options);\n    return createImage(dataURL);\n}\nasync function cloneIFrameElement(iframe) {\n    var _a;\n    try {\n        if ((_a = iframe === null || iframe === void 0 ? void 0 : iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.body) {\n            return (await cloneNode(iframe.contentDocument.body, {}, true));\n        }\n    }\n    catch (_b) {\n        // Failed to clone iframe\n    }\n    return iframe.cloneNode(false);\n}\nasync function cloneSingleNode(node, options) {\n    if (isInstanceOfElement(node, HTMLCanvasElement)) {\n        return cloneCanvasElement(node);\n    }\n    if (isInstanceOfElement(node, HTMLVideoElement)) {\n        return cloneVideoElement(node, options);\n    }\n    if (isInstanceOfElement(node, HTMLIFrameElement)) {\n        return cloneIFrameElement(node);\n    }\n    return node.cloneNode(false);\n}\nconst isSlotElement = (node) => node.tagName != null && node.tagName.toUpperCase() === 'SLOT';\nasync function cloneChildren(nativeNode, clonedNode, options) {\n    var _a, _b;\n    let children = [];\n    if (isSlotElement(nativeNode) && nativeNode.assignedNodes) {\n        children = toArray(nativeNode.assignedNodes());\n    }\n    else if (isInstanceOfElement(nativeNode, HTMLIFrameElement) &&\n        ((_a = nativeNode.contentDocument) === null || _a === void 0 ? void 0 : _a.body)) {\n        children = toArray(nativeNode.contentDocument.body.childNodes);\n    }\n    else {\n        children = toArray(((_b = nativeNode.shadowRoot) !== null && _b !== void 0 ? _b : nativeNode).childNodes);\n    }\n    if (children.length === 0 ||\n        isInstanceOfElement(nativeNode, HTMLVideoElement)) {\n        return clonedNode;\n    }\n    await children.reduce((deferred, child) => deferred\n        .then(() => cloneNode(child, options))\n        .then((clonedChild) => {\n        if (clonedChild) {\n            clonedNode.appendChild(clonedChild);\n        }\n    }), Promise.resolve());\n    return clonedNode;\n}\nfunction cloneCSSStyle(nativeNode, clonedNode) {\n    const targetStyle = clonedNode.style;\n    if (!targetStyle) {\n        return;\n    }\n    const sourceStyle = window.getComputedStyle(nativeNode);\n    if (sourceStyle.cssText) {\n        targetStyle.cssText = sourceStyle.cssText;\n        targetStyle.transformOrigin = sourceStyle.transformOrigin;\n    }\n    else {\n        toArray(sourceStyle).forEach((name) => {\n            let value = sourceStyle.getPropertyValue(name);\n            if (name === 'font-size' && value.endsWith('px')) {\n                const reducedFont = Math.floor(parseFloat(value.substring(0, value.length - 2))) - 0.1;\n                value = `${reducedFont}px`;\n            }\n            if (isInstanceOfElement(nativeNode, HTMLIFrameElement) &&\n                name === 'display' &&\n                value === 'inline') {\n                value = 'block';\n            }\n            if (name === 'd' && clonedNode.getAttribute('d')) {\n                value = `path(${clonedNode.getAttribute('d')})`;\n            }\n            targetStyle.setProperty(name, value, sourceStyle.getPropertyPriority(name));\n        });\n    }\n}\nfunction cloneInputValue(nativeNode, clonedNode) {\n    if (isInstanceOfElement(nativeNode, HTMLTextAreaElement)) {\n        clonedNode.innerHTML = nativeNode.value;\n    }\n    if (isInstanceOfElement(nativeNode, HTMLInputElement)) {\n        clonedNode.setAttribute('value', nativeNode.value);\n    }\n}\nfunction cloneSelectValue(nativeNode, clonedNode) {\n    if (isInstanceOfElement(nativeNode, HTMLSelectElement)) {\n        const clonedSelect = clonedNode;\n        const selectedOption = Array.from(clonedSelect.children).find((child) => nativeNode.value === child.getAttribute('value'));\n        if (selectedOption) {\n            selectedOption.setAttribute('selected', '');\n        }\n    }\n}\nfunction decorate(nativeNode, clonedNode) {\n    if (isInstanceOfElement(clonedNode, Element)) {\n        cloneCSSStyle(nativeNode, clonedNode);\n        clonePseudoElements(nativeNode, clonedNode);\n        cloneInputValue(nativeNode, clonedNode);\n        cloneSelectValue(nativeNode, clonedNode);\n    }\n    return clonedNode;\n}\nasync function ensureSVGSymbols(clone, options) {\n    const uses = clone.querySelectorAll ? clone.querySelectorAll('use') : [];\n    if (uses.length === 0) {\n        return clone;\n    }\n    const processedDefs = {};\n    for (let i = 0; i < uses.length; i++) {\n        const use = uses[i];\n        const id = use.getAttribute('xlink:href');\n        if (id) {\n            const exist = clone.querySelector(id);\n            const definition = document.querySelector(id);\n            if (!exist && definition && !processedDefs[id]) {\n                // eslint-disable-next-line no-await-in-loop\n                processedDefs[id] = (await cloneNode(definition, options, true));\n            }\n        }\n    }\n    const nodes = Object.values(processedDefs);\n    if (nodes.length) {\n        const ns = 'http://www.w3.org/1999/xhtml';\n        const svg = document.createElementNS(ns, 'svg');\n        svg.setAttribute('xmlns', ns);\n        svg.style.position = 'absolute';\n        svg.style.width = '0';\n        svg.style.height = '0';\n        svg.style.overflow = 'hidden';\n        svg.style.display = 'none';\n        const defs = document.createElementNS(ns, 'defs');\n        svg.appendChild(defs);\n        for (let i = 0; i < nodes.length; i++) {\n            defs.appendChild(nodes[i]);\n        }\n        clone.appendChild(svg);\n    }\n    return clone;\n}\nexport async function cloneNode(node, options, isRoot) {\n    if (!isRoot && options.filter && !options.filter(node)) {\n        return null;\n    }\n    return Promise.resolve(node)\n        .then((clonedNode) => cloneSingleNode(clonedNode, options))\n        .then((clonedNode) => cloneChildren(node, clonedNode, options))\n        .then((clonedNode) => decorate(node, clonedNode))\n        .then((clonedNode) => ensureSVGSymbols(clonedNode, options));\n}\n//# sourceMappingURL=clone-node.js.map","import type { Options } from './types'\nimport { clonePseudoElements } from './clone-pseudos'\nimport { createImage, toArray, isInstanceOfElement } from './util'\nimport { getMimeType } from './mimes'\nimport { resourceToDataURL } from './dataurl'\n\nasync function cloneCanvasElement(canvas: HTMLCanvasElement) {\n  const dataURL = canvas.toDataURL()\n  if (dataURL === 'data:,') {\n    return canvas.cloneNode(false) as HTMLCanvasElement\n  }\n  return createImage(dataURL)\n}\n\nasync function cloneVideoElement(video: HTMLVideoElement, options: Options) {\n  if (video.currentSrc) {\n    const canvas = document.createElement('canvas')\n    const ctx = canvas.getContext('2d')\n    canvas.width = video.clientWidth\n    canvas.height = video.clientHeight\n    ctx?.drawImage(video, 0, 0, canvas.width, canvas.height)\n    const dataURL = canvas.toDataURL()\n    return createImage(dataURL)\n  }\n\n  const poster = video.poster\n  const contentType = getMimeType(poster)\n  const dataURL = await resourceToDataURL(poster, contentType, options)\n  return createImage(dataURL)\n}\n\nasync function cloneIFrameElement(iframe: HTMLIFrameElement) {\n  try {\n    if (iframe?.contentDocument?.body) {\n      return (await cloneNode(\n        iframe.contentDocument.body,\n        {},\n        true,\n      )) as HTMLBodyElement\n    }\n  } catch {\n    // Failed to clone iframe\n  }\n\n  return iframe.cloneNode(false) as HTMLIFrameElement\n}\n\nasync function cloneSingleNode<T extends HTMLElement>(\n  node: T,\n  options: Options,\n): Promise<HTMLElement> {\n  if (isInstanceOfElement(node, HTMLCanvasElement)) {\n    return cloneCanvasElement(node)\n  }\n\n  if (isInstanceOfElement(node, HTMLVideoElement)) {\n    return cloneVideoElement(node, options)\n  }\n\n  if (isInstanceOfElement(node, HTMLIFrameElement)) {\n    return cloneIFrameElement(node)\n  }\n\n  return node.cloneNode(false) as T\n}\n\nconst isSlotElement = (node: HTMLElement): node is HTMLSlotElement =>\n  node.tagName != null && node.tagName.toUpperCase() === 'SLOT'\n\nasync function cloneChildren<T extends HTMLElement>(\n  nativeNode: T,\n  clonedNode: T,\n  options: Options,\n): Promise<T> {\n  let children: T[] = []\n\n  if (isSlotElement(nativeNode) && nativeNode.assignedNodes) {\n    children = toArray<T>(nativeNode.assignedNodes())\n  } else if (\n    isInstanceOfElement(nativeNode, HTMLIFrameElement) &&\n    nativeNode.contentDocument?.body\n  ) {\n    children = toArray<T>(nativeNode.contentDocument.body.childNodes)\n  } else {\n    children = toArray<T>((nativeNode.shadowRoot ?? nativeNode).childNodes)\n  }\n\n  if (\n    children.length === 0 ||\n    isInstanceOfElement(nativeNode, HTMLVideoElement)\n  ) {\n    return clonedNode\n  }\n\n  await children.reduce(\n    (deferred, child) =>\n      deferred\n        .then(() => cloneNode(child, options))\n        .then((clonedChild: HTMLElement | null) => {\n          if (clonedChild) {\n            clonedNode.appendChild(clonedChild)\n          }\n        }),\n    Promise.resolve(),\n  )\n\n  return clonedNode\n}\n\nfunction cloneCSSStyle<T extends HTMLElement>(nativeNode: T, clonedNode: T) {\n  const targetStyle = clonedNode.style\n  if (!targetStyle) {\n    return\n  }\n\n  const sourceStyle = window.getComputedStyle(nativeNode)\n  if (sourceStyle.cssText) {\n    targetStyle.cssText = sourceStyle.cssText\n    targetStyle.transformOrigin = sourceStyle.transformOrigin\n  } else {\n    toArray<string>(sourceStyle).forEach((name) => {\n      let value = sourceStyle.getPropertyValue(name)\n      if (name === 'font-size' && value.endsWith('px')) {\n        const reducedFont =\n          Math.floor(parseFloat(value.substring(0, value.length - 2))) - 0.1\n        value = `${reducedFont}px`\n      }\n\n      if (\n        isInstanceOfElement(nativeNode, HTMLIFrameElement) &&\n        name === 'display' &&\n        value === 'inline'\n      ) {\n        value = 'block'\n      }\n      \n      if (name === 'd' && clonedNode.getAttribute('d')) {\n        value = `path(${clonedNode.getAttribute('d')})`\n      }\n      \n      targetStyle.setProperty(\n        name,\n        value,\n        sourceStyle.getPropertyPriority(name),\n      )\n    })\n  }\n}\n\nfunction cloneInputValue<T extends HTMLElement>(nativeNode: T, clonedNode: T) {\n  if (isInstanceOfElement(nativeNode, HTMLTextAreaElement)) {\n    clonedNode.innerHTML = nativeNode.value\n  }\n\n  if (isInstanceOfElement(nativeNode, HTMLInputElement)) {\n    clonedNode.setAttribute('value', nativeNode.value)\n  }\n}\n\nfunction cloneSelectValue<T extends HTMLElement>(nativeNode: T, clonedNode: T) {\n  if (isInstanceOfElement(nativeNode, HTMLSelectElement)) {\n    const clonedSelect = clonedNode as any as HTMLSelectElement\n    const selectedOption = Array.from(clonedSelect.children).find(\n      (child) => nativeNode.value === child.getAttribute('value'),\n    )\n\n    if (selectedOption) {\n      selectedOption.setAttribute('selected', '')\n    }\n  }\n}\n\nfunction decorate<T extends HTMLElement>(nativeNode: T, clonedNode: T): T {\n  if (isInstanceOfElement(clonedNode, Element)) {\n    cloneCSSStyle(nativeNode, clonedNode)\n    clonePseudoElements(nativeNode, clonedNode)\n    cloneInputValue(nativeNode, clonedNode)\n    cloneSelectValue(nativeNode, clonedNode)\n  }\n\n  return clonedNode\n}\n\nasync function ensureSVGSymbols<T extends HTMLElement>(\n  clone: T,\n  options: Options,\n) {\n  const uses = clone.querySelectorAll ? clone.querySelectorAll('use') : []\n  if (uses.length === 0) {\n    return clone\n  }\n\n  const processedDefs: { [key: string]: HTMLElement } = {}\n  for (let i = 0; i < uses.length; i++) {\n    const use = uses[i]\n    const id = use.getAttribute('xlink:href')\n    if (id) {\n      const exist = clone.querySelector(id)\n      const definition = document.querySelector(id) as HTMLElement\n      if (!exist && definition && !processedDefs[id]) {\n        // eslint-disable-next-line no-await-in-loop\n        processedDefs[id] = (await cloneNode(definition, options, true))!\n      }\n    }\n  }\n\n  const nodes = Object.values(processedDefs)\n  if (nodes.length) {\n    const ns = 'http://www.w3.org/1999/xhtml'\n    const svg = document.createElementNS(ns, 'svg')\n    svg.setAttribute('xmlns', ns)\n    svg.style.position = 'absolute'\n    svg.style.width = '0'\n    svg.style.height = '0'\n    svg.style.overflow = 'hidden'\n    svg.style.display = 'none'\n\n    const defs = document.createElementNS(ns, 'defs')\n    svg.appendChild(defs)\n\n    for (let i = 0; i < nodes.length; i++) {\n      defs.appendChild(nodes[i])\n    }\n\n    clone.appendChild(svg)\n  }\n\n  return clone\n}\n\nexport async function cloneNode<T extends HTMLElement>(\n  node: T,\n  options: Options,\n  isRoot?: boolean,\n): Promise<T | null> {\n  if (!isRoot && options.filter && !options.filter(node)) {\n    return null\n  }\n\n  return Promise.resolve(node)\n    .then((clonedNode) => cloneSingleNode(clonedNode, options) as Promise<T>)\n    .then((clonedNode) => cloneChildren(node, clonedNode, options))\n    .then((clonedNode) => decorate(node, clonedNode))\n    .then((clonedNode) => ensureSVGSymbols(clonedNode, options))\n}\n","import { uuid, toArray } from './util';\nfunction formatCSSText(style) {\n    const content = style.getPropertyValue('content');\n    return `${style.cssText} content: '${content.replace(/'|\"/g, '')}';`;\n}\nfunction formatCSSProperties(style) {\n    return toArray(style)\n        .map((name) => {\n        const value = style.getPropertyValue(name);\n        const priority = style.getPropertyPriority(name);\n        return `${name}: ${value}${priority ? ' !important' : ''};`;\n    })\n        .join(' ');\n}\nfunction getPseudoElementStyle(className, pseudo, style) {\n    const selector = `.${className}:${pseudo}`;\n    const cssText = style.cssText\n        ? formatCSSText(style)\n        : formatCSSProperties(style);\n    return document.createTextNode(`${selector}{${cssText}}`);\n}\nfunction clonePseudoElement(nativeNode, clonedNode, pseudo) {\n    const style = window.getComputedStyle(nativeNode, pseudo);\n    const content = style.getPropertyValue('content');\n    if (content === '' || content === 'none') {\n        return;\n    }\n    const className = uuid();\n    try {\n        clonedNode.className = `${clonedNode.className} ${className}`;\n    }\n    catch (err) {\n        return;\n    }\n    const styleElement = document.createElement('style');\n    styleElement.appendChild(getPseudoElementStyle(className, pseudo, style));\n    clonedNode.appendChild(styleElement);\n}\nexport function clonePseudoElements(nativeNode, clonedNode) {\n    clonePseudoElement(nativeNode, clonedNode, ':before');\n    clonePseudoElement(nativeNode, clonedNode, ':after');\n}\n//# sourceMappingURL=clone-pseudos.js.map","import { uuid, toArray } from './util'\n\ntype Pseudo = ':before' | ':after'\n\nfunction formatCSSText(style: CSSStyleDeclaration) {\n  const content = style.getPropertyValue('content')\n  return `${style.cssText} content: '${content.replace(/'|\"/g, '')}';`\n}\n\nfunction formatCSSProperties(style: CSSStyleDeclaration) {\n  return toArray<string>(style)\n    .map((name) => {\n      const value = style.getPropertyValue(name)\n      const priority = style.getPropertyPriority(name)\n\n      return `${name}: ${value}${priority ? ' !important' : ''};`\n    })\n    .join(' ')\n}\n\nfunction getPseudoElementStyle(\n  className: string,\n  pseudo: Pseudo,\n  style: CSSStyleDeclaration,\n): Text {\n  const selector = `.${className}:${pseudo}`\n  const cssText = style.cssText\n    ? formatCSSText(style)\n    : formatCSSProperties(style)\n\n  return document.createTextNode(`${selector}{${cssText}}`)\n}\n\nfunction clonePseudoElement<T extends HTMLElement>(\n  nativeNode: T,\n  clonedNode: T,\n  pseudo: Pseudo,\n) {\n  const style = window.getComputedStyle(nativeNode, pseudo)\n  const content = style.getPropertyValue('content')\n  if (content === '' || content === 'none') {\n    return\n  }\n\n  const className = uuid()\n  try {\n    clonedNode.className = `${clonedNode.className} ${className}`\n  } catch (err) {\n    return\n  }\n\n  const styleElement = document.createElement('style')\n  styleElement.appendChild(getPseudoElementStyle(className, pseudo, style))\n  clonedNode.appendChild(styleElement)\n}\n\nexport function clonePseudoElements<T extends HTMLElement>(\n  nativeNode: T,\n  clonedNode: T,\n) {\n  clonePseudoElement(nativeNode, clonedNode, ':before')\n  clonePseudoElement(nativeNode, clonedNode, ':after')\n}\n","export function resolveUrl(url, baseUrl) {\n    // url is absolute already\n    if (url.match(/^[a-z]+:\\/\\//i)) {\n        return url;\n    }\n    // url is absolute already, without protocol\n    if (url.match(/^\\/\\//)) {\n        return window.location.protocol + url;\n    }\n    // dataURI, mailto:, tel:, etc.\n    if (url.match(/^[a-z]+:/i)) {\n        return url;\n    }\n    const doc = document.implementation.createHTMLDocument();\n    const base = doc.createElement('base');\n    const a = doc.createElement('a');\n    doc.head.appendChild(base);\n    doc.body.appendChild(a);\n    if (baseUrl) {\n        base.href = baseUrl;\n    }\n    a.href = url;\n    return a.href;\n}\nexport const uuid = (() => {\n    // generate uuid for className of pseudo elements.\n    // We should not use GUIDs, otherwise pseudo elements sometimes cannot be captured.\n    let counter = 0;\n    // ref: http://stackoverflow.com/a/6248722/2519373\n    const random = () => \n    // eslint-disable-next-line no-bitwise\n    `0000${((Math.random() * 36 ** 4) << 0).toString(36)}`.slice(-4);\n    return () => {\n        counter += 1;\n        return `u${random()}${counter}`;\n    };\n})();\nexport function delay(ms) {\n    return (args) => new Promise((resolve) => {\n        setTimeout(() => resolve(args), ms);\n    });\n}\nexport function toArray(arrayLike) {\n    const arr = [];\n    for (let i = 0, l = arrayLike.length; i < l; i++) {\n        arr.push(arrayLike[i]);\n    }\n    return arr;\n}\nfunction px(node, styleProperty) {\n    const win = node.ownerDocument.defaultView || window;\n    const val = win.getComputedStyle(node).getPropertyValue(styleProperty);\n    return val ? parseFloat(val.replace('px', '')) : 0;\n}\nfunction getNodeWidth(node) {\n    const leftBorder = px(node, 'border-left-width');\n    const rightBorder = px(node, 'border-right-width');\n    return node.clientWidth + leftBorder + rightBorder;\n}\nfunction getNodeHeight(node) {\n    const topBorder = px(node, 'border-top-width');\n    const bottomBorder = px(node, 'border-bottom-width');\n    return node.clientHeight + topBorder + bottomBorder;\n}\nexport function getImageSize(targetNode, options = {}) {\n    const width = options.width || getNodeWidth(targetNode);\n    const height = options.height || getNodeHeight(targetNode);\n    return { width, height };\n}\nexport function getPixelRatio() {\n    let ratio;\n    let FINAL_PROCESS;\n    try {\n        FINAL_PROCESS = process;\n    }\n    catch (e) {\n        // pass\n    }\n    const val = FINAL_PROCESS && FINAL_PROCESS.env\n        ? FINAL_PROCESS.env.devicePixelRatio\n        : null;\n    if (val) {\n        ratio = parseInt(val, 10);\n        if (Number.isNaN(ratio)) {\n            ratio = 1;\n        }\n    }\n    return ratio || window.devicePixelRatio || 1;\n}\n// @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas#maximum_canvas_size\nconst canvasDimensionLimit = 16384;\nexport function checkCanvasDimensions(canvas) {\n    if (canvas.width > canvasDimensionLimit ||\n        canvas.height > canvasDimensionLimit) {\n        if (canvas.width > canvasDimensionLimit &&\n            canvas.height > canvasDimensionLimit) {\n            if (canvas.width > canvas.height) {\n                canvas.height *= canvasDimensionLimit / canvas.width;\n                canvas.width = canvasDimensionLimit;\n            }\n            else {\n                canvas.width *= canvasDimensionLimit / canvas.height;\n                canvas.height = canvasDimensionLimit;\n            }\n        }\n        else if (canvas.width > canvasDimensionLimit) {\n            canvas.height *= canvasDimensionLimit / canvas.width;\n            canvas.width = canvasDimensionLimit;\n        }\n        else {\n            canvas.width *= canvasDimensionLimit / canvas.height;\n            canvas.height = canvasDimensionLimit;\n        }\n    }\n}\nexport function canvasToBlob(canvas, options = {}) {\n    if (canvas.toBlob) {\n        return new Promise((resolve) => {\n            canvas.toBlob(resolve, options.type ? options.type : 'image/png', options.quality ? options.quality : 1);\n        });\n    }\n    return new Promise((resolve) => {\n        const binaryString = window.atob(canvas\n            .toDataURL(options.type ? options.type : undefined, options.quality ? options.quality : undefined)\n            .split(',')[1]);\n        const len = binaryString.length;\n        const binaryArray = new Uint8Array(len);\n        for (let i = 0; i < len; i += 1) {\n            binaryArray[i] = binaryString.charCodeAt(i);\n        }\n        resolve(new Blob([binaryArray], {\n            type: options.type ? options.type : 'image/png',\n        }));\n    });\n}\nexport function createImage(url) {\n    return new Promise((resolve, reject) => {\n        const img = new Image();\n        img.decode = () => resolve(img);\n        img.onload = () => resolve(img);\n        img.onerror = reject;\n        img.crossOrigin = 'anonymous';\n        img.decoding = 'async';\n        img.src = url;\n    });\n}\nexport async function svgToDataURL(svg) {\n    return Promise.resolve()\n        .then(() => new XMLSerializer().serializeToString(svg))\n        .then(encodeURIComponent)\n        .then((html) => `data:image/svg+xml;charset=utf-8,${html}`);\n}\nexport async function nodeToDataURL(node, width, height) {\n    const xmlns = 'http://www.w3.org/2000/svg';\n    const svg = document.createElementNS(xmlns, 'svg');\n    const foreignObject = document.createElementNS(xmlns, 'foreignObject');\n    svg.setAttribute('width', `${width}`);\n    svg.setAttribute('height', `${height}`);\n    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);\n    foreignObject.setAttribute('width', '100%');\n    foreignObject.setAttribute('height', '100%');\n    foreignObject.setAttribute('x', '0');\n    foreignObject.setAttribute('y', '0');\n    foreignObject.setAttribute('externalResourcesRequired', 'true');\n    svg.appendChild(foreignObject);\n    foreignObject.appendChild(node);\n    return svgToDataURL(svg);\n}\nexport const isInstanceOfElement = (node, instance) => {\n    if (node instanceof instance)\n        return true;\n    const nodePrototype = Object.getPrototypeOf(node);\n    if (nodePrototype === null)\n        return false;\n    return (nodePrototype.constructor.name === instance.name ||\n        isInstanceOfElement(nodePrototype, instance));\n};\n//# sourceMappingURL=util.js.map","import type { Options } from './types'\n\nexport function resolveUrl(url: string, baseUrl: string | null): string {\n  // url is absolute already\n  if (url.match(/^[a-z]+:\\/\\//i)) {\n    return url\n  }\n\n  // url is absolute already, without protocol\n  if (url.match(/^\\/\\//)) {\n    return window.location.protocol + url\n  }\n\n  // dataURI, mailto:, tel:, etc.\n  if (url.match(/^[a-z]+:/i)) {\n    return url\n  }\n\n  const doc = document.implementation.createHTMLDocument()\n  const base = doc.createElement('base')\n  const a = doc.createElement('a')\n\n  doc.head.appendChild(base)\n  doc.body.appendChild(a)\n\n  if (baseUrl) {\n    base.href = baseUrl\n  }\n\n  a.href = url\n\n  return a.href\n}\n\nexport const uuid = (() => {\n  // generate uuid for className of pseudo elements.\n  // We should not use GUIDs, otherwise pseudo elements sometimes cannot be captured.\n  let counter = 0\n\n  // ref: http://stackoverflow.com/a/6248722/2519373\n  const random = () =>\n    // eslint-disable-next-line no-bitwise\n    `0000${((Math.random() * 36 ** 4) << 0).toString(36)}`.slice(-4)\n\n  return () => {\n    counter += 1\n    return `u${random()}${counter}`\n  }\n})()\n\nexport function delay<T>(ms: number) {\n  return (args: T) =>\n    new Promise<T>((resolve) => {\n      setTimeout(() => resolve(args), ms)\n    })\n}\n\nexport function toArray<T>(arrayLike: any): T[] {\n  const arr: T[] = []\n\n  for (let i = 0, l = arrayLike.length; i < l; i++) {\n    arr.push(arrayLike[i])\n  }\n\n  return arr\n}\n\nfunction px(node: HTMLElement, styleProperty: string) {\n  const win = node.ownerDocument.defaultView || window\n  const val = win.getComputedStyle(node).getPropertyValue(styleProperty)\n  return val ? parseFloat(val.replace('px', '')) : 0\n}\n\nfunction getNodeWidth(node: HTMLElement) {\n  const leftBorder = px(node, 'border-left-width')\n  const rightBorder = px(node, 'border-right-width')\n  return node.clientWidth + leftBorder + rightBorder\n}\n\nfunction getNodeHeight(node: HTMLElement) {\n  const topBorder = px(node, 'border-top-width')\n  const bottomBorder = px(node, 'border-bottom-width')\n  return node.clientHeight + topBorder + bottomBorder\n}\n\nexport function getImageSize(targetNode: HTMLElement, options: Options = {}) {\n  const width = options.width || getNodeWidth(targetNode)\n  const height = options.height || getNodeHeight(targetNode)\n\n  return { width, height }\n}\n\nexport function getPixelRatio() {\n  let ratio\n\n  let FINAL_PROCESS\n  try {\n    FINAL_PROCESS = process\n  } catch (e) {\n    // pass\n  }\n\n  const val =\n    FINAL_PROCESS && FINAL_PROCESS.env\n      ? FINAL_PROCESS.env.devicePixelRatio\n      : null\n  if (val) {\n    ratio = parseInt(val, 10)\n    if (Number.isNaN(ratio)) {\n      ratio = 1\n    }\n  }\n  return ratio || window.devicePixelRatio || 1\n}\n\n// @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas#maximum_canvas_size\nconst canvasDimensionLimit = 16384\n\nexport function checkCanvasDimensions(canvas: HTMLCanvasElement) {\n  if (\n    canvas.width > canvasDimensionLimit ||\n    canvas.height > canvasDimensionLimit\n  ) {\n    if (\n      canvas.width > canvasDimensionLimit &&\n      canvas.height > canvasDimensionLimit\n    ) {\n      if (canvas.width > canvas.height) {\n        canvas.height *= canvasDimensionLimit / canvas.width\n        canvas.width = canvasDimensionLimit\n      } else {\n        canvas.width *= canvasDimensionLimit / canvas.height\n        canvas.height = canvasDimensionLimit\n      }\n    } else if (canvas.width > canvasDimensionLimit) {\n      canvas.height *= canvasDimensionLimit / canvas.width\n      canvas.width = canvasDimensionLimit\n    } else {\n      canvas.width *= canvasDimensionLimit / canvas.height\n      canvas.height = canvasDimensionLimit\n    }\n  }\n}\n\nexport function canvasToBlob(\n  canvas: HTMLCanvasElement,\n  options: Options = {},\n): Promise<Blob | null> {\n  if (canvas.toBlob) {\n    return new Promise((resolve) => {\n      canvas.toBlob(\n        resolve,\n        options.type ? options.type : 'image/png',\n        options.quality ? options.quality : 1,\n      )\n    })\n  }\n\n  return new Promise((resolve) => {\n    const binaryString = window.atob(\n      canvas\n        .toDataURL(\n          options.type ? options.type : undefined,\n          options.quality ? options.quality : undefined,\n        )\n        .split(',')[1],\n    )\n    const len = binaryString.length\n    const binaryArray = new Uint8Array(len)\n\n    for (let i = 0; i < len; i += 1) {\n      binaryArray[i] = binaryString.charCodeAt(i)\n    }\n\n    resolve(\n      new Blob([binaryArray], {\n        type: options.type ? options.type : 'image/png',\n      }),\n    )\n  })\n}\n\nexport function createImage(url: string): Promise<HTMLImageElement> {\n  return new Promise((resolve, reject) => {\n    const img = new Image()\n    img.decode = () => resolve(img) as any\n    img.onload = () => resolve(img)\n    img.onerror = reject\n    img.crossOrigin = 'anonymous'\n    img.decoding = 'async'\n    img.src = url\n  })\n}\n\nexport async function svgToDataURL(svg: SVGElement): Promise<string> {\n  return Promise.resolve()\n    .then(() => new XMLSerializer().serializeToString(svg))\n    .then(encodeURIComponent)\n    .then((html) => `data:image/svg+xml;charset=utf-8,${html}`)\n}\n\nexport async function nodeToDataURL(\n  node: HTMLElement,\n  width: number,\n  height: number,\n): Promise<string> {\n  const xmlns = 'http://www.w3.org/2000/svg'\n  const svg = document.createElementNS(xmlns, 'svg')\n  const foreignObject = document.createElementNS(xmlns, 'foreignObject')\n\n  svg.setAttribute('width', `${width}`)\n  svg.setAttribute('height', `${height}`)\n  svg.setAttribute('viewBox', `0 0 ${width} ${height}`)\n\n  foreignObject.setAttribute('width', '100%')\n  foreignObject.setAttribute('height', '100%')\n  foreignObject.setAttribute('x', '0')\n  foreignObject.setAttribute('y', '0')\n  foreignObject.setAttribute('externalResourcesRequired', 'true')\n\n  svg.appendChild(foreignObject)\n  foreignObject.appendChild(node)\n  return svgToDataURL(svg)\n}\n\nexport const isInstanceOfElement = <\n  T extends typeof Element | typeof HTMLElement | typeof SVGImageElement,\n>(\n  node: Element | HTMLElement | SVGImageElement,\n  instance: T,\n): node is T['prototype'] => {\n  if (node instanceof instance) return true\n\n  const nodePrototype = Object.getPrototypeOf(node)\n\n  if (nodePrototype === null) return false\n\n  return (\n    nodePrototype.constructor.name === instance.name ||\n    isInstanceOfElement(nodePrototype, instance)\n  )\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","const WOFF = 'application/font-woff';\nconst JPEG = 'image/jpeg';\nconst mimes = {\n    woff: WOFF,\n    woff2: WOFF,\n    ttf: 'application/font-truetype',\n    eot: 'application/vnd.ms-fontobject',\n    png: 'image/png',\n    jpg: JPEG,\n    jpeg: JPEG,\n    gif: 'image/gif',\n    tiff: 'image/tiff',\n    svg: 'image/svg+xml',\n    webp: 'image/webp',\n};\nfunction getExtension(url) {\n    const match = /\\.([^./]*?)$/g.exec(url);\n    return match ? match[1] : '';\n}\nexport function getMimeType(url) {\n    const extension = getExtension(url).toLowerCase();\n    return mimes[extension] || '';\n}\n//# sourceMappingURL=mimes.js.map","const WOFF = 'application/font-woff'\nconst JPEG = 'image/jpeg'\nconst mimes: { [key: string]: string } = {\n  woff: WOFF,\n  woff2: WOFF,\n  ttf: 'application/font-truetype',\n  eot: 'application/vnd.ms-fontobject',\n  png: 'image/png',\n  jpg: JPEG,\n  jpeg: JPEG,\n  gif: 'image/gif',\n  tiff: 'image/tiff',\n  svg: 'image/svg+xml',\n  webp: 'image/webp',\n}\n\nfunction getExtension(url: string): string {\n  const match = /\\.([^./]*?)$/g.exec(url)\n  return match ? match[1] : ''\n}\n\nexport function getMimeType(url: string): string {\n  const extension = getExtension(url).toLowerCase()\n  return mimes[extension] || ''\n}\n","function getContentFromDataUrl(dataURL) {\n    return dataURL.split(/,/)[1];\n}\nexport function isDataUrl(url) {\n    return url.search(/^(data:)/) !== -1;\n}\nexport function makeDataUrl(content, mimeType) {\n    return `data:${mimeType};base64,${content}`;\n}\nexport async function fetchAsDataURL(url, init, process) {\n    const res = await fetch(url, init);\n    if (res.status === 404) {\n        throw new Error(`Resource \"${res.url}\" not found`);\n    }\n    const blob = await res.blob();\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onerror = reject;\n        reader.onloadend = () => {\n            try {\n                resolve(process({ res, result: reader.result }));\n            }\n            catch (error) {\n                reject(error);\n            }\n        };\n        reader.readAsDataURL(blob);\n    });\n}\nconst cache = {};\nfunction getCacheKey(url, contentType, includeQueryParams) {\n    let key = url.replace(/\\?.*/, '');\n    if (includeQueryParams) {\n        key = url;\n    }\n    // font resource\n    if (/ttf|otf|eot|woff2?/i.test(key)) {\n        key = key.replace(/.*\\//, '');\n    }\n    return contentType ? `[${contentType}]${key}` : key;\n}\nexport async function resourceToDataURL(resourceUrl, contentType, options) {\n    const cacheKey = getCacheKey(resourceUrl, contentType, options.includeQueryParams);\n    if (cache[cacheKey] != null) {\n        return cache[cacheKey];\n    }\n    // ref: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache\n    if (options.cacheBust) {\n        // eslint-disable-next-line no-param-reassign\n        resourceUrl += (/\\?/.test(resourceUrl) ? '&' : '?') + new Date().getTime();\n    }\n    let dataURL;\n    try {\n        const content = await fetchAsDataURL(resourceUrl, options.fetchRequestInit, ({ res, result }) => {\n            if (!contentType) {\n                // eslint-disable-next-line no-param-reassign\n                contentType = res.headers.get('Content-Type') || '';\n            }\n            return getContentFromDataUrl(result);\n        });\n        dataURL = makeDataUrl(content, contentType);\n    }\n    catch (error) {\n        dataURL = options.imagePlaceholder || '';\n        let msg = `Failed to fetch resource: ${resourceUrl}`;\n        if (error) {\n            msg = typeof error === 'string' ? error : error.message;\n        }\n        if (msg) {\n            console.warn(msg);\n        }\n    }\n    cache[cacheKey] = dataURL;\n    return dataURL;\n}\n//# sourceMappingURL=dataurl.js.map","import { Options } from './types'\n\nfunction getContentFromDataUrl(dataURL: string) {\n  return dataURL.split(/,/)[1]\n}\n\nexport function isDataUrl(url: string) {\n  return url.search(/^(data:)/) !== -1\n}\n\nexport function makeDataUrl(content: string, mimeType: string) {\n  return `data:${mimeType};base64,${content}`\n}\n\nexport async function fetchAsDataURL<T>(\n  url: string,\n  init: RequestInit | undefined,\n  process: (data: { result: string; res: Response }) => T,\n): Promise<T> {\n  const res = await fetch(url, init)\n  if (res.status === 404) {\n    throw new Error(`Resource \"${res.url}\" not found`)\n  }\n  const blob = await res.blob()\n  return new Promise<T>((resolve, reject) => {\n    const reader = new FileReader()\n    reader.onerror = reject\n    reader.onloadend = () => {\n      try {\n        resolve(process({ res, result: reader.result as string }))\n      } catch (error) {\n        reject(error)\n      }\n    }\n\n    reader.readAsDataURL(blob)\n  })\n}\n\nconst cache: { [url: string]: string } = {}\n\nfunction getCacheKey(\n  url: string,\n  contentType: string | undefined,\n  includeQueryParams: boolean | undefined,\n) {\n  let key = url.replace(/\\?.*/, '')\n\n  if (includeQueryParams) {\n    key = url\n  }\n\n  // font resource\n  if (/ttf|otf|eot|woff2?/i.test(key)) {\n    key = key.replace(/.*\\//, '')\n  }\n\n  return contentType ? `[${contentType}]${key}` : key\n}\n\nexport async function resourceToDataURL(\n  resourceUrl: string,\n  contentType: string | undefined,\n  options: Options,\n) {\n  const cacheKey = getCacheKey(\n    resourceUrl,\n    contentType,\n    options.includeQueryParams,\n  )\n\n  if (cache[cacheKey] != null) {\n    return cache[cacheKey]\n  }\n\n  // ref: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache\n  if (options.cacheBust) {\n    // eslint-disable-next-line no-param-reassign\n    resourceUrl += (/\\?/.test(resourceUrl) ? '&' : '?') + new Date().getTime()\n  }\n\n  let dataURL: string\n  try {\n    const content = await fetchAsDataURL(\n      resourceUrl,\n      options.fetchRequestInit,\n      ({ res, result }) => {\n        if (!contentType) {\n          // eslint-disable-next-line no-param-reassign\n          contentType = res.headers.get('Content-Type') || ''\n        }\n        return getContentFromDataUrl(result)\n      },\n    )\n    dataURL = makeDataUrl(content, contentType!)\n  } catch (error) {\n    dataURL = options.imagePlaceholder || ''\n\n    let msg = `Failed to fetch resource: ${resourceUrl}`\n    if (error) {\n      msg = typeof error === 'string' ? error : error.message\n    }\n\n    if (msg) {\n      console.warn(msg)\n    }\n  }\n\n  cache[cacheKey] = dataURL\n  return dataURL\n}\n","import { embedResources } from './embed-resources';\nimport { toArray, isInstanceOfElement } from './util';\nimport { isDataUrl, resourceToDataURL } from './dataurl';\nimport { getMimeType } from './mimes';\nasync function embedProp(propName, node, options) {\n    var _a;\n    const propValue = (_a = node.style) === null || _a === void 0 ? void 0 : _a.getPropertyValue(propName);\n    if (propValue) {\n        const cssString = await embedResources(propValue, null, options);\n        node.style.setProperty(propName, cssString, node.style.getPropertyPriority(propName));\n        return true;\n    }\n    return false;\n}\nasync function embedBackground(clonedNode, options) {\n    if (!(await embedProp('background', clonedNode, options))) {\n        await embedProp('background-image', clonedNode, options);\n    }\n    if (!(await embedProp('mask', clonedNode, options))) {\n        await embedProp('mask-image', clonedNode, options);\n    }\n}\nasync function embedImageNode(clonedNode, options) {\n    const isImageElement = isInstanceOfElement(clonedNode, HTMLImageElement);\n    if (!(isImageElement && !isDataUrl(clonedNode.src)) &&\n        !(isInstanceOfElement(clonedNode, SVGImageElement) &&\n            !isDataUrl(clonedNode.href.baseVal))) {\n        return;\n    }\n    const url = isImageElement ? clonedNode.src : clonedNode.href.baseVal;\n    const dataURL = await resourceToDataURL(url, getMimeType(url), options);\n    await new Promise((resolve, reject) => {\n        clonedNode.onload = resolve;\n        clonedNode.onerror = reject;\n        const image = clonedNode;\n        if (image.decode) {\n            image.decode = resolve;\n        }\n        if (image.loading === 'lazy') {\n            image.loading = 'eager';\n        }\n        if (isImageElement) {\n            clonedNode.srcset = '';\n            clonedNode.src = dataURL;\n        }\n        else {\n            clonedNode.href.baseVal = dataURL;\n        }\n    });\n}\nasync function embedChildren(clonedNode, options) {\n    const children = toArray(clonedNode.childNodes);\n    const deferreds = children.map((child) => embedImages(child, options));\n    await Promise.all(deferreds).then(() => clonedNode);\n}\nexport async function embedImages(clonedNode, options) {\n    if (isInstanceOfElement(clonedNode, Element)) {\n        await embedBackground(clonedNode, options);\n        await embedImageNode(clonedNode, options);\n        await embedChildren(clonedNode, options);\n    }\n}\n//# sourceMappingURL=embed-images.js.map","import { Options } from './types'\nimport { embedResources } from './embed-resources'\nimport { toArray, isInstanceOfElement } from './util'\nimport { isDataUrl, resourceToDataURL } from './dataurl'\nimport { getMimeType } from './mimes'\n\nasync function embedProp(\n  propName: string,\n  node: HTMLElement,\n  options: Options,\n) {\n  const propValue = node.style?.getPropertyValue(propName)\n  if (propValue) {\n    const cssString = await embedResources(propValue, null, options)\n    node.style.setProperty(\n      propName,\n      cssString,\n      node.style.getPropertyPriority(propName),\n    )\n    return true\n  }\n  return false\n}\n\nasync function embedBackground<T extends HTMLElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  if (!(await embedProp('background', clonedNode, options))) {\n    await embedProp('background-image', clonedNode, options)\n  }\n  if (!(await embedProp('mask', clonedNode, options))) {\n    await embedProp('mask-image', clonedNode, options)\n  }\n}\n\nasync function embedImageNode<T extends HTMLElement | SVGImageElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  const isImageElement = isInstanceOfElement(clonedNode, HTMLImageElement)\n\n  if (\n    !(isImageElement && !isDataUrl(clonedNode.src)) &&\n    !(\n      isInstanceOfElement(clonedNode, SVGImageElement) &&\n      !isDataUrl(clonedNode.href.baseVal)\n    )\n  ) {\n    return\n  }\n\n  const url = isImageElement ? clonedNode.src : clonedNode.href.baseVal\n\n  const dataURL = await resourceToDataURL(url, getMimeType(url), options)\n  await new Promise((resolve, reject) => {\n    clonedNode.onload = resolve\n    clonedNode.onerror = reject\n\n    const image = clonedNode as HTMLImageElement\n    if (image.decode) {\n      image.decode = resolve as any\n    }\n\n    if (image.loading === 'lazy') {\n      image.loading = 'eager'\n    }\n\n    if (isImageElement) {\n      clonedNode.srcset = ''\n      clonedNode.src = dataURL\n    } else {\n      clonedNode.href.baseVal = dataURL\n    }\n  })\n}\n\nasync function embedChildren<T extends HTMLElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  const children = toArray<HTMLElement>(clonedNode.childNodes)\n  const deferreds = children.map((child) => embedImages(child, options))\n  await Promise.all(deferreds).then(() => clonedNode)\n}\n\nexport async function embedImages<T extends HTMLElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  if (isInstanceOfElement(clonedNode, Element)) {\n    await embedBackground(clonedNode, options)\n    await embedImageNode(clonedNode, options)\n    await embedChildren(clonedNode, options)\n  }\n}\n","import { resolveUrl } from './util';\nimport { getMimeType } from './mimes';\nimport { isDataUrl, makeDataUrl, resourceToDataURL } from './dataurl';\nconst URL_REGEX = /url\\((['\"]?)([^'\"]+?)\\1\\)/g;\nconst URL_WITH_FORMAT_REGEX = /url\\([^)]+\\)\\s*format\\(([\"']?)([^\"']+)\\1\\)/g;\nconst FONT_SRC_REGEX = /src:\\s*(?:url\\([^)]+\\)\\s*format\\([^)]+\\)[,;]\\s*)+/g;\nfunction toRegex(url) {\n    // eslint-disable-next-line no-useless-escape\n    const escaped = url.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n    return new RegExp(`(url\\\\(['\"]?)(${escaped})(['\"]?\\\\))`, 'g');\n}\nexport function parseURLs(cssText) {\n    const urls = [];\n    cssText.replace(URL_REGEX, (raw, quotation, url) => {\n        urls.push(url);\n        return raw;\n    });\n    return urls.filter((url) => !isDataUrl(url));\n}\nexport async function embed(cssText, resourceURL, baseURL, options, getContentFromUrl) {\n    try {\n        const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL;\n        const contentType = getMimeType(resourceURL);\n        let dataURL;\n        if (getContentFromUrl) {\n            const content = await getContentFromUrl(resolvedURL);\n            dataURL = makeDataUrl(content, contentType);\n        }\n        else {\n            dataURL = await resourceToDataURL(resolvedURL, contentType, options);\n        }\n        return cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`);\n    }\n    catch (error) {\n        // pass\n    }\n    return cssText;\n}\nfunction filterPreferredFontFormat(str, { preferredFontFormat }) {\n    return !preferredFontFormat\n        ? str\n        : str.replace(FONT_SRC_REGEX, (match) => {\n            // eslint-disable-next-line no-constant-condition\n            while (true) {\n                const [src, , format] = URL_WITH_FORMAT_REGEX.exec(match) || [];\n                if (!format) {\n                    return '';\n                }\n                if (format === preferredFontFormat) {\n                    return `src: ${src};`;\n                }\n            }\n        });\n}\nexport function shouldEmbed(url) {\n    return url.search(URL_REGEX) !== -1;\n}\nexport async function embedResources(cssText, baseUrl, options) {\n    if (!shouldEmbed(cssText)) {\n        return cssText;\n    }\n    const filteredCSSText = filterPreferredFontFormat(cssText, options);\n    const urls = parseURLs(filteredCSSText);\n    return urls.reduce((deferred, url) => deferred.then((css) => embed(css, url, baseUrl, options)), Promise.resolve(filteredCSSText));\n}\n//# sourceMappingURL=embed-resources.js.map","import { Options } from './types'\nimport { resolveUrl } from './util'\nimport { getMimeType } from './mimes'\nimport { isDataUrl, makeDataUrl, resourceToDataURL } from './dataurl'\n\nconst URL_REGEX = /url\\((['\"]?)([^'\"]+?)\\1\\)/g\nconst URL_WITH_FORMAT_REGEX = /url\\([^)]+\\)\\s*format\\(([\"']?)([^\"']+)\\1\\)/g\nconst FONT_SRC_REGEX = /src:\\s*(?:url\\([^)]+\\)\\s*format\\([^)]+\\)[,;]\\s*)+/g\n\nfunction toRegex(url: string): RegExp {\n  // eslint-disable-next-line no-useless-escape\n  const escaped = url.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, '\\\\$1')\n  return new RegExp(`(url\\\\(['\"]?)(${escaped})(['\"]?\\\\))`, 'g')\n}\n\nexport function parseURLs(cssText: string): string[] {\n  const urls: string[] = []\n\n  cssText.replace(URL_REGEX, (raw, quotation, url) => {\n    urls.push(url)\n    return raw\n  })\n\n  return urls.filter((url) => !isDataUrl(url))\n}\n\nexport async function embed(\n  cssText: string,\n  resourceURL: string,\n  baseURL: string | null,\n  options: Options,\n  getContentFromUrl?: (url: string) => Promise<string>,\n): Promise<string> {\n  try {\n    const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL\n    const contentType = getMimeType(resourceURL)\n    let dataURL: string\n    if (getContentFromUrl) {\n      const content = await getContentFromUrl(resolvedURL)\n      dataURL = makeDataUrl(content, contentType)\n    } else {\n      dataURL = await resourceToDataURL(resolvedURL, contentType, options)\n    }\n    return cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`)\n  } catch (error) {\n    // pass\n  }\n  return cssText\n}\n\nfunction filterPreferredFontFormat(\n  str: string,\n  { preferredFontFormat }: Options,\n): string {\n  return !preferredFontFormat\n    ? str\n    : str.replace(FONT_SRC_REGEX, (match: string) => {\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n          const [src, , format] = URL_WITH_FORMAT_REGEX.exec(match) || []\n          if (!format) {\n            return ''\n          }\n\n          if (format === preferredFontFormat) {\n            return `src: ${src};`\n          }\n        }\n      })\n}\n\nexport function shouldEmbed(url: string): boolean {\n  return url.search(URL_REGEX) !== -1\n}\n\nexport async function embedResources(\n  cssText: string,\n  baseUrl: string | null,\n  options: Options,\n): Promise<string> {\n  if (!shouldEmbed(cssText)) {\n    return cssText\n  }\n\n  const filteredCSSText = filterPreferredFontFormat(cssText, options)\n  const urls = parseURLs(filteredCSSText)\n  return urls.reduce(\n    (deferred, url) =>\n      deferred.then((css) => embed(css, url, baseUrl, options)),\n    Promise.resolve(filteredCSSText),\n  )\n}\n","export function applyStyle(node, options) {\n    const { style } = node;\n    if (options.backgroundColor) {\n        style.backgroundColor = options.backgroundColor;\n    }\n    if (options.width) {\n        style.width = `${options.width}px`;\n    }\n    if (options.height) {\n        style.height = `${options.height}px`;\n    }\n    const manual = options.style;\n    if (manual != null) {\n        Object.keys(manual).forEach((key) => {\n            style[key] = manual[key];\n        });\n    }\n    return node;\n}\n//# sourceMappingURL=apply-style.js.map","import { Options } from './types'\n\nexport function applyStyle<T extends HTMLElement>(\n  node: T,\n  options: Options,\n): T {\n  const { style } = node\n\n  if (options.backgroundColor) {\n    style.backgroundColor = options.backgroundColor\n  }\n\n  if (options.width) {\n    style.width = `${options.width}px`\n  }\n\n  if (options.height) {\n    style.height = `${options.height}px`\n  }\n\n  const manual = options.style\n  if (manual != null) {\n    Object.keys(manual).forEach((key: any) => {\n      style[key] = manual[key] as string\n    })\n  }\n\n  return node\n}\n","import { toArray } from './util';\nimport { fetchAsDataURL } from './dataurl';\nimport { shouldEmbed, embedResources } from './embed-resources';\nconst cssFetchCache = {};\nasync function fetchCSS(url) {\n    let cache = cssFetchCache[url];\n    if (cache != null) {\n        return cache;\n    }\n    const res = await fetch(url);\n    const cssText = await res.text();\n    cache = { url, cssText };\n    cssFetchCache[url] = cache;\n    return cache;\n}\nasync function embedFonts(data, options) {\n    let cssText = data.cssText;\n    const regexUrl = /url\\([\"']?([^\"')]+)[\"']?\\)/g;\n    const fontLocs = cssText.match(/url\\([^)]+\\)/g) || [];\n    const loadFonts = fontLocs.map(async (loc) => {\n        let url = loc.replace(regexUrl, '$1');\n        if (!url.startsWith('https://')) {\n            url = new URL(url, data.url).href;\n        }\n        return fetchAsDataURL(url, options.fetchRequestInit, ({ result }) => {\n            cssText = cssText.replace(loc, `url(${result})`);\n            return [loc, result];\n        });\n    });\n    return Promise.all(loadFonts).then(() => cssText);\n}\nfunction parseCSS(source) {\n    if (source == null) {\n        return [];\n    }\n    const result = [];\n    const commentsRegex = /(\\/\\*[\\s\\S]*?\\*\\/)/gi;\n    // strip out comments\n    let cssText = source.replace(commentsRegex, '');\n    // eslint-disable-next-line prefer-regex-literals\n    const keyframesRegex = new RegExp('((@.*?keyframes [\\\\s\\\\S]*?){([\\\\s\\\\S]*?}\\\\s*?)})', 'gi');\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        const matches = keyframesRegex.exec(cssText);\n        if (matches === null) {\n            break;\n        }\n        result.push(matches[0]);\n    }\n    cssText = cssText.replace(keyframesRegex, '');\n    const importRegex = /@import[\\s\\S]*?url\\([^)]*\\)[\\s\\S]*?;/gi;\n    // to match css & media queries together\n    const combinedCSSRegex = '((\\\\s*?(?:\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/)?\\\\s*?@media[\\\\s\\\\S]' +\n        '*?){([\\\\s\\\\S]*?)}\\\\s*?})|(([\\\\s\\\\S]*?){([\\\\s\\\\S]*?)})';\n    // unified regex\n    const unifiedRegex = new RegExp(combinedCSSRegex, 'gi');\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        let matches = importRegex.exec(cssText);\n        if (matches === null) {\n            matches = unifiedRegex.exec(cssText);\n            if (matches === null) {\n                break;\n            }\n            else {\n                importRegex.lastIndex = unifiedRegex.lastIndex;\n            }\n        }\n        else {\n            unifiedRegex.lastIndex = importRegex.lastIndex;\n        }\n        result.push(matches[0]);\n    }\n    return result;\n}\nasync function getCSSRules(styleSheets, options) {\n    const ret = [];\n    const deferreds = [];\n    // First loop inlines imports\n    styleSheets.forEach((sheet) => {\n        if ('cssRules' in sheet) {\n            try {\n                toArray(sheet.cssRules || []).forEach((item, index) => {\n                    if (item.type === CSSRule.IMPORT_RULE) {\n                        let importIndex = index + 1;\n                        const url = item.href;\n                        const deferred = fetchCSS(url)\n                            .then((metadata) => embedFonts(metadata, options))\n                            .then((cssText) => parseCSS(cssText).forEach((rule) => {\n                            try {\n                                sheet.insertRule(rule, rule.startsWith('@import')\n                                    ? (importIndex += 1)\n                                    : sheet.cssRules.length);\n                            }\n                            catch (error) {\n                                console.error('Error inserting rule from remote css', {\n                                    rule,\n                                    error,\n                                });\n                            }\n                        }))\n                            .catch((e) => {\n                            console.error('Error loading remote css', e.toString());\n                        });\n                        deferreds.push(deferred);\n                    }\n                });\n            }\n            catch (e) {\n                const inline = styleSheets.find((a) => a.href == null) || document.styleSheets[0];\n                if (sheet.href != null) {\n                    deferreds.push(fetchCSS(sheet.href)\n                        .then((metadata) => embedFonts(metadata, options))\n                        .then((cssText) => parseCSS(cssText).forEach((rule) => {\n                        inline.insertRule(rule, sheet.cssRules.length);\n                    }))\n                        .catch((err) => {\n                        console.error('Error loading remote stylesheet', err);\n                    }));\n                }\n                console.error('Error inlining remote css file', e);\n            }\n        }\n    });\n    return Promise.all(deferreds).then(() => {\n        // Second loop parses rules\n        styleSheets.forEach((sheet) => {\n            if ('cssRules' in sheet) {\n                try {\n                    toArray(sheet.cssRules || []).forEach((item) => {\n                        ret.push(item);\n                    });\n                }\n                catch (e) {\n                    console.error(`Error while reading CSS rules from ${sheet.href}`, e);\n                }\n            }\n        });\n        return ret;\n    });\n}\nfunction getWebFontRules(cssRules) {\n    return cssRules\n        .filter((rule) => rule.type === CSSRule.FONT_FACE_RULE)\n        .filter((rule) => shouldEmbed(rule.style.getPropertyValue('src')));\n}\nasync function parseWebFontRules(node, options) {\n    if (node.ownerDocument == null) {\n        throw new Error('Provided element is not within a Document');\n    }\n    const styleSheets = toArray(node.ownerDocument.styleSheets);\n    const cssRules = await getCSSRules(styleSheets, options);\n    return getWebFontRules(cssRules);\n}\nexport async function getWebFontCSS(node, options) {\n    const rules = await parseWebFontRules(node, options);\n    const cssTexts = await Promise.all(rules.map((rule) => {\n        const baseUrl = rule.parentStyleSheet ? rule.parentStyleSheet.href : null;\n        return embedResources(rule.cssText, baseUrl, options);\n    }));\n    return cssTexts.join('\\n');\n}\nexport async function embedWebFonts(clonedNode, options) {\n    const cssText = options.fontEmbedCSS != null\n        ? options.fontEmbedCSS\n        : options.skipFonts\n            ? null\n            : await getWebFontCSS(clonedNode, options);\n    if (cssText) {\n        const styleNode = document.createElement('style');\n        const sytleContent = document.createTextNode(cssText);\n        styleNode.appendChild(sytleContent);\n        if (clonedNode.firstChild) {\n            clonedNode.insertBefore(styleNode, clonedNode.firstChild);\n        }\n        else {\n            clonedNode.appendChild(styleNode);\n        }\n    }\n}\n//# sourceMappingURL=embed-webfonts.js.map","import type { Options } from './types'\nimport { toArray } from './util'\nimport { fetchAsDataURL } from './dataurl'\nimport { shouldEmbed, embedResources } from './embed-resources'\n\ninterface Metadata {\n  url: string\n  cssText: string\n}\n\nconst cssFetchCache: { [href: string]: Metadata } = {}\n\nasync function fetchCSS(url: string) {\n  let cache = cssFetchCache[url]\n  if (cache != null) {\n    return cache\n  }\n\n  const res = await fetch(url)\n  const cssText = await res.text()\n  cache = { url, cssText }\n\n  cssFetchCache[url] = cache\n\n  return cache\n}\n\nasync function embedFonts(data: Metadata, options: Options): Promise<string> {\n  let cssText = data.cssText\n  const regexUrl = /url\\([\"']?([^\"')]+)[\"']?\\)/g\n  const fontLocs = cssText.match(/url\\([^)]+\\)/g) || []\n  const loadFonts = fontLocs.map(async (loc: string) => {\n    let url = loc.replace(regexUrl, '$1')\n    if (!url.startsWith('https://')) {\n      url = new URL(url, data.url).href\n    }\n\n    return fetchAsDataURL<[string, string]>(\n      url,\n      options.fetchRequestInit,\n      ({ result }) => {\n        cssText = cssText.replace(loc, `url(${result})`)\n        return [loc, result]\n      },\n    )\n  })\n\n  return Promise.all(loadFonts).then(() => cssText)\n}\n\nfunction parseCSS(source: string) {\n  if (source == null) {\n    return []\n  }\n\n  const result: string[] = []\n  const commentsRegex = /(\\/\\*[\\s\\S]*?\\*\\/)/gi\n  // strip out comments\n  let cssText = source.replace(commentsRegex, '')\n\n  // eslint-disable-next-line prefer-regex-literals\n  const keyframesRegex = new RegExp(\n    '((@.*?keyframes [\\\\s\\\\S]*?){([\\\\s\\\\S]*?}\\\\s*?)})',\n    'gi',\n  )\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const matches = keyframesRegex.exec(cssText)\n    if (matches === null) {\n      break\n    }\n    result.push(matches[0])\n  }\n  cssText = cssText.replace(keyframesRegex, '')\n\n  const importRegex = /@import[\\s\\S]*?url\\([^)]*\\)[\\s\\S]*?;/gi\n  // to match css & media queries together\n  const combinedCSSRegex =\n    '((\\\\s*?(?:\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/)?\\\\s*?@media[\\\\s\\\\S]' +\n    '*?){([\\\\s\\\\S]*?)}\\\\s*?})|(([\\\\s\\\\S]*?){([\\\\s\\\\S]*?)})'\n  // unified regex\n  const unifiedRegex = new RegExp(combinedCSSRegex, 'gi')\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let matches = importRegex.exec(cssText)\n    if (matches === null) {\n      matches = unifiedRegex.exec(cssText)\n      if (matches === null) {\n        break\n      } else {\n        importRegex.lastIndex = unifiedRegex.lastIndex\n      }\n    } else {\n      unifiedRegex.lastIndex = importRegex.lastIndex\n    }\n    result.push(matches[0])\n  }\n\n  return result\n}\n\nasync function getCSSRules(\n  styleSheets: CSSStyleSheet[],\n  options: Options,\n): Promise<CSSStyleRule[]> {\n  const ret: CSSStyleRule[] = []\n  const deferreds: Promise<number | void>[] = []\n\n  // First loop inlines imports\n  styleSheets.forEach((sheet) => {\n    if ('cssRules' in sheet) {\n      try {\n        toArray<CSSRule>(sheet.cssRules || []).forEach((item, index) => {\n          if (item.type === CSSRule.IMPORT_RULE) {\n            let importIndex = index + 1\n            const url = (item as CSSImportRule).href\n            const deferred = fetchCSS(url)\n              .then((metadata) => embedFonts(metadata, options))\n              .then((cssText) =>\n                parseCSS(cssText).forEach((rule) => {\n                  try {\n                    sheet.insertRule(\n                      rule,\n                      rule.startsWith('@import')\n                        ? (importIndex += 1)\n                        : sheet.cssRules.length,\n                    )\n                  } catch (error) {\n                    console.error('Error inserting rule from remote css', {\n                      rule,\n                      error,\n                    })\n                  }\n                }),\n              )\n              .catch((e) => {\n                console.error('Error loading remote css', e.toString())\n              })\n\n            deferreds.push(deferred)\n          }\n        })\n      } catch (e) {\n        const inline =\n          styleSheets.find((a) => a.href == null) || document.styleSheets[0]\n        if (sheet.href != null) {\n          deferreds.push(\n            fetchCSS(sheet.href)\n              .then((metadata) => embedFonts(metadata, options))\n              .then((cssText) =>\n                parseCSS(cssText).forEach((rule) => {\n                  inline.insertRule(rule, sheet.cssRules.length)\n                }),\n              )\n              .catch((err: unknown) => {\n                console.error('Error loading remote stylesheet', err)\n              }),\n          )\n        }\n        console.error('Error inlining remote css file', e)\n      }\n    }\n  })\n\n  return Promise.all(deferreds).then(() => {\n    // Second loop parses rules\n    styleSheets.forEach((sheet) => {\n      if ('cssRules' in sheet) {\n        try {\n          toArray<CSSStyleRule>(sheet.cssRules || []).forEach((item) => {\n            ret.push(item)\n          })\n        } catch (e) {\n          console.error(`Error while reading CSS rules from ${sheet.href}`, e)\n        }\n      }\n    })\n\n    return ret\n  })\n}\n\nfunction getWebFontRules(cssRules: CSSStyleRule[]): CSSStyleRule[] {\n  return cssRules\n    .filter((rule) => rule.type === CSSRule.FONT_FACE_RULE)\n    .filter((rule) => shouldEmbed(rule.style.getPropertyValue('src')))\n}\n\nasync function parseWebFontRules<T extends HTMLElement>(\n  node: T,\n  options: Options,\n) {\n  if (node.ownerDocument == null) {\n    throw new Error('Provided element is not within a Document')\n  }\n\n  const styleSheets = toArray<CSSStyleSheet>(node.ownerDocument.styleSheets)\n  const cssRules = await getCSSRules(styleSheets, options)\n\n  return getWebFontRules(cssRules)\n}\n\nexport async function getWebFontCSS<T extends HTMLElement>(\n  node: T,\n  options: Options,\n): Promise<string> {\n  const rules = await parseWebFontRules(node, options)\n  const cssTexts = await Promise.all(\n    rules.map((rule) => {\n      const baseUrl = rule.parentStyleSheet ? rule.parentStyleSheet.href : null\n      return embedResources(rule.cssText, baseUrl, options)\n    }),\n  )\n\n  return cssTexts.join('\\n')\n}\n\nexport async function embedWebFonts<T extends HTMLElement>(\n  clonedNode: T,\n  options: Options,\n) {\n  const cssText =\n    options.fontEmbedCSS != null\n      ? options.fontEmbedCSS\n      : options.skipFonts\n      ? null\n      : await getWebFontCSS(clonedNode, options)\n\n  if (cssText) {\n    const styleNode = document.createElement('style')\n    const sytleContent = document.createTextNode(cssText)\n\n    styleNode.appendChild(sytleContent)\n\n    if (clonedNode.firstChild) {\n      clonedNode.insertBefore(styleNode, clonedNode.firstChild)\n    } else {\n      clonedNode.appendChild(styleNode)\n    }\n  }\n}\n"],"names":["$b6370854aea1ab9c$export$14333815d08d1368","DOM_SHOT_EXT_ACTION","$b6370854aea1ab9c$export$87e24ddbab2613d9","$d3c1734dacb01657$var$cachedSetTimeout","$d3c1734dacb01657$var$cachedClearTimeout","$d3c1734dacb01657$var$currentQueue","$cb692f5b2b7518ec$exports","JSON","parse","$c498bb1c05d876ef$export$3c628e933563550d","message","optionalParams","console","log","$c498bb1c05d876ef$export$a2b6a13999826ac7","version","buildTime","$d3c1734dacb01657$exports","$d3c1734dacb01657$var$process","$d3c1734dacb01657$var$defaultSetTimout","Error","$d3c1734dacb01657$var$defaultClearTimeout","$d3c1734dacb01657$var$runTimeout","fun","setTimeout","e","call","clearTimeout","$d3c1734dacb01657$var$queue","$d3c1734dacb01657$var$draining","$d3c1734dacb01657$var$queueIndex","$d3c1734dacb01657$var$cleanUpNextTick","length","concat","$d3c1734dacb01657$var$drainQueue","timeout","len","run","$d3c1734dacb01657$var$runClearTimeout","marker","$d3c1734dacb01657$var$Item","array","$d3c1734dacb01657$var$noop","nextTick","args","Array","arguments","i","push","prototype","apply","title","browser","env","argv","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","$3f38c4817eb4f38b$export$31b40729666a4ae0","counter","random","Math","toString","slice","$3f38c4817eb4f38b$export$45b10814cc054894","arrayLike","arr","l","$3f38c4817eb4f38b$var$px","node","styleProperty","win","ownerDocument","defaultView","window","val","getComputedStyle","getPropertyValue","parseFloat","replace","$3f38c4817eb4f38b$export$ada5537b2c061996","targetNode","options","width","$3f38c4817eb4f38b$var$getNodeWidth","leftBorder","rightBorder","clientWidth","height","$3f38c4817eb4f38b$var$getNodeHeight","topBorder","bottomBorder","clientHeight","$3f38c4817eb4f38b$export$ec664d7487540b","url","Promise","resolve","reject","img","Image","decode","onload","onerror","crossOrigin","decoding","src","$3f38c4817eb4f38b$export$fe77aa9c02de4599","svg","then","XMLSerializer","serializeToString","encodeURIComponent","html","$3f38c4817eb4f38b$export$b62810fb8ca515fa","xmlns","document","createElementNS","foreignObject","setAttribute","appendChild","$3f38c4817eb4f38b$export$3a92fc9ec83ef360","instance","nodePrototype","Object","getPrototypeOf","constructor","$5dc335fc18f5c31c$var$clonePseudoElement","nativeNode","clonedNode","pseudo","style","content","className","err","styleElement","createElement","$5dc335fc18f5c31c$var$getPseudoElementStyle","selector","cssText","$5dc335fc18f5c31c$var$formatCSSText","map","value","priority","getPropertyPriority","join","createTextNode","$932a96ce56c3bc50$var$WOFF","$932a96ce56c3bc50$var$JPEG","$932a96ce56c3bc50$var$mimes","woff","woff2","ttf","eot","png","jpg","jpeg","gif","tiff","webp","$932a96ce56c3bc50$export$200548c990602f61","extension","$932a96ce56c3bc50$var$getExtension","match","exec","toLowerCase","$36f8c7f53bd1328c$export$f8a05efa20ffd5a","search","$36f8c7f53bd1328c$export$68336ea1617fa80a","mimeType","$36f8c7f53bd1328c$export$c20a8b76c95b0d41","init","process","res","fetch","status","blob","reader","FileReader","onloadend","result","error","readAsDataURL","$36f8c7f53bd1328c$var$cache","$36f8c7f53bd1328c$export$bdf0422c029b202a","resourceUrl","contentType","includeQueryParams","dataURL","key","cacheKey","test","cacheBust","Date","getTime","fetchRequestInit","headers","get","split","imagePlaceholder","msg","warn","$e4993691940aed80$var$cloneCanvasElement","canvas","toDataURL","cloneNode","$e4993691940aed80$var$cloneVideoElement","video","currentSrc","ctx","getContext","drawImage","poster","$e4993691940aed80$var$cloneIFrameElement","iframe","_a","contentDocument","body","$e4993691940aed80$export$ae8e35ea29ddac22","_b","$e4993691940aed80$var$cloneSingleNode","HTMLCanvasElement","HTMLVideoElement","HTMLIFrameElement","$e4993691940aed80$var$isSlotElement","tagName","toUpperCase","$e4993691940aed80$var$cloneChildren","children","assignedNodes","childNodes","shadowRoot","reduce","deferred","child","clonedChild","$e4993691940aed80$var$ensureSVGSymbols","clone","uses","querySelectorAll","processedDefs","use","id","getAttribute","exist","querySelector","definition","nodes","values","ns","position","overflow","display","defs","isRoot","filter","Element","$e4993691940aed80$var$cloneCSSStyle","targetStyle","sourceStyle","transformOrigin","forEach","endsWith","reducedFont","floor","substring","setProperty","HTMLTextAreaElement","innerHTML","HTMLInputElement","$e4993691940aed80$var$cloneSelectValue","HTMLSelectElement","selectedOption","from","clonedSelect","find","$6f23389cdbe0dece$var$URL_REGEX","$6f23389cdbe0dece$var$URL_WITH_FORMAT_REGEX","$6f23389cdbe0dece$var$FONT_SRC_REGEX","$6f23389cdbe0dece$export$2be46bb7e96db87f","resourceURL","baseURL","getContentFromUrl","resolvedURL","baseUrl","location","protocol","doc","implementation","createHTMLDocument","base","a","head","href","$6f23389cdbe0dece$var$toRegex","escaped","RegExp","$6f23389cdbe0dece$export$7b668369e5eab853","$6f23389cdbe0dece$export$3d88803585cbbc21","filteredCSSText","$6f23389cdbe0dece$var$filterPreferredFontFormat","str","preferredFontFormat","format","urls","$6f23389cdbe0dece$export$d04549d631b8762d","raw","quotation","css","$d00e8710aa74d8f2$var$embedProp","propName","propValue","cssString","$d00e8710aa74d8f2$var$embedBackground","$d00e8710aa74d8f2$var$embedImageNode","isImageElement","HTMLImageElement","SVGImageElement","baseVal","image","loading","srcset","$d00e8710aa74d8f2$var$embedChildren","deferreds","$d00e8710aa74d8f2$export$6660fa8dd20e53aa","all","$e00ffe9f0e6cf773$var$cssFetchCache","$e00ffe9f0e6cf773$var$fetchCSS","cache","text","$e00ffe9f0e6cf773$var$embedFonts","data","regexUrl","fontLocs","loadFonts","loc","startsWith","URL","$e00ffe9f0e6cf773$var$parseCSS","source","keyframesRegex","matches","importRegex","unifiedRegex","lastIndex","$e00ffe9f0e6cf773$var$getCSSRules","styleSheets","ret","sheet","cssRules","item","index","type","CSSRule","IMPORT_RULE","importIndex","metadata","rule","insertRule","catch","inline","$e00ffe9f0e6cf773$var$parseWebFontRules","FONT_FACE_RULE","$e00ffe9f0e6cf773$export$253c9aa3d83a57b6","rules","cssTexts","parentStyleSheet","$e00ffe9f0e6cf773$export$2c2c83b77c8cb421","fontEmbedCSS","skipFonts","styleNode","sytleContent","firstChild","insertBefore","$49e912db89b35827$export$20d300cb2d558b7","backgroundColor","manual","keys","datauri","$49e912db89b35827$export$f87f6982d1fd4f81","context","ratio","pixelRatio","FINAL_PROCESS","devicePixelRatio","Number","isNaN","parseInt","canvasWidth","canvasHeight","skipAutoScale","$3f38c4817eb4f38b$var$canvasDimensionLimit","fillStyle","fillRect","$49e912db89b35827$export$aba256f33615c92e","$048c0dc54e08960c$export$4778991634f78fa5","element","imgData","postMessage","action","domShot","payload","$24add57b2feb7361$var$DOM_SHOT_HELPER_KEY","helper","tabId","clearEvent","initUtils","messageHandler","event","utilsActionMap","removeEventListener","addEventListener"],"version":3,"file":"helper.js.map"}